// Copyright 2025 - 2026 The excelize Authors. All rights reserved. Use of this
// source code is governed by a BSD-style license that can be found in the
// LICENSE file.
//
// Package excelize-cs is a C# port of Go Excelize library, providing a set of
// functions that allow you to write and read from XLAM / XLSM / XLSX / XLTM /
// XLTX files. Supports reading and writing spreadsheet documents generated by
// Microsoft Excelâ„¢ 2007 and later. Supports complex components by high
// compatibility, and provided streaming API for generating or reading data from
// a worksheet with huge amounts of data. This library needs .NET version 6, C#
// version 10 or later.

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;

namespace ExcelizeCs
{
    public static class Lib
    {
        private const string LibraryName = "libexcelize";
        public const string ErrUnsupportedPlatformOrArch =
            "This platform or architecture is not supported.";

        static Lib()
        {
            NativeLibrary.SetDllImportResolver(Assembly.GetExecutingAssembly(), DllImportResolver);
        }

        public static IntPtr DllImportResolver(
            string libraryName,
            Assembly assembly,
            DllImportSearchPath? searchPath
        )
        {
            var extMap = new Dictionary<string, string>
            {
                { "linux", ".so" },
                { "darwin", ".dylib" },
                { "windows", ".dll" },
            };
            var osList = new List<(bool, List<string>)>
            {
                (
                    RuntimeInformation.IsOSPlatform(OSPlatform.Windows),
                    new List<string> { "windows", ".dll" }
                ),
                (
                    RuntimeInformation.IsOSPlatform(OSPlatform.Linux),
                    new List<string> { "linux", ".so" }
                ),
                (
                    RuntimeInformation.IsOSPlatform(OSPlatform.OSX),
                    new List<string> { "darwin", ".dylib" }
                ),
            };
            var archMap = new Dictionary<Architecture, string>
            {
                { Architecture.X64, "amd64" },
                { Architecture.X86, "386" },
                { Architecture.Arm64, "arm64" },
            };
            string ext = "";
            string system = "";
            var os = osList.Find(os => os.Item1);
            if (os.Item1)
            {
                system = os.Item2[0];
                ext = os.Item2[1];
            }
            string lib = Path.Combine(
                AppDomain.CurrentDomain.BaseDirectory,
                $"{libraryName}.{archMap[RuntimeInformation.ProcessArchitecture]}.{system}{ext}"
            );
            if (NativeLibrary.TryLoad(lib, out IntPtr handle))
            {
                return handle;
            }
            throw new RuntimeError(ErrUnsupportedPlatformOrArch);
        }

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddChart(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell,
            [In, MarshalAs(UnmanagedType.LPArray)] TypesC.Chart[] chart,
            int length
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddChartSheet(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [In, MarshalAs(UnmanagedType.LPArray)] TypesC.Chart[] chart,
            int length
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddComment(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.Comment comment
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddFormControl(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.FormControl options
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddHeaderFooterImage(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.HeaderFooterImageOptions options
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddIgnoredErrors(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string rangeRef,
            byte ignoredErrorsType
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddPicture(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string name,
            ref TypesC.GraphicOptions opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddPictureFromBytes(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell,
            ref TypesC.Picture pic
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddPivotTable(
            long fileIdx,
            ref TypesC.PivotTableOptions opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddShape(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.Shape opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddSlicer(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.SlicerOptions opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddSparkline(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.SparklineOptions opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddTable(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.Table opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AddVBAProject(long fileIdx, byte[] b, int bLen);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.StringErrorResult CalcCellValue(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell,
            ref TypesC.Options options
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr AutoFilter(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string range,
            [In, MarshalAs(UnmanagedType.LPArray)] TypesC.AutoFilterOptions[] options,
            int length
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.CellNameToCoordinatesResult CellNameToCoordinates(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr Close(long fileIdx);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr CopySheet(long fileIdx, int from, int to);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.IntErrorResult ColumnNameToNumber(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string name
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.StringErrorResult ColumnNumberToName(int num);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.StringErrorResult CoordinatesToCellName(
            int col,
            int row,
            bool abs
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr DeleteChart(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr DeleteComment(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr DeletePicture(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr DeleteSheet(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr DeleteSlicer(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string name
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr DuplicateRow(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            int row
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr DuplicateRowTo(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            int row,
            int row2
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int GetActiveSheetIndex(long fileIdx);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.GetAppPropsResult GetAppProps(long fileIdx);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.GetCalcPropsResult GetCalcProps(long fileIdx);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.StringErrorResult GetCellFormula(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.StringErrorResult JoinCellName(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string col,
            int row
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.StringIntErrorResult SplitCellName(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.StringErrorResult GetCellValue(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell,
            ref TypesC.Options opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.StringMatrixErrorResult GetRows(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.Options opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.GetStyleResult GetStyle(long fileIdx, long styleID);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern long NewFile();

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.IntErrorResult NewSheet(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.IntErrorResult NewStreamWriter(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.IntErrorResult NewStyle(long fileIdx, ref TypesC.Style style);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.IntErrorResult OpenFile(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string filename,
            ref TypesC.Options options
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern TypesC.IntErrorResult OpenReader(
            byte[] b,
            int bLen,
            ref TypesC.Options options
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr Save(long fileIdx, ref TypesC.Options options);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SaveAs(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string filename,
            ref TypesC.Options options
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetActiveSheet(long fileIdx, int index);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetAppProps(
            long fileIdx,
            ref TypesC.AppProperties appProperties
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetCalcProps(long fileIdx, ref TypesC.CalcPropsOptions opts);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetCellBool(
            long fileIdx,
            string sheet,
            string cell,
            bool value
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetCellDefault(
            long fileIdx,
            string sheet,
            string cell,
            string value
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetCellFormula(
            long fileIdx,
            string sheet,
            string cell,
            string formula,
            ref TypesC.FormulaOpts opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetCellInt(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell,
            long value
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetCellStyle(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string topLeftCell,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string bottomRightCell,
            long styleID
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetCellValue(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell,
            ref TypesC.Interface value
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetSheetProps(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.SheetPropsOptions options
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetHeaderFooter(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            ref TypesC.HeaderFooterOptions opts
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr SetSheetRow(
            long fileIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string sheet,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell,
            [In, MarshalAs(UnmanagedType.LPArray)] TypesC.Interface[] row,
            int length
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr StreamFlush(long swIdx);

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr StreamSetRow(
            long swIdx,
            [MarshalAs(UnmanagedType.LPUTF8Str)] string cell,
            [In, MarshalAs(UnmanagedType.LPArray)] TypesC.Interface[] row,
            int length
        );

        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr UpdateLinkedValue(long fileIdx);

        /// <summary>
        /// Checks if is a nullable object reference type, for example: Class?.
        /// </summary>
        /// <param name="field"></param>
        /// <returns></returns>
        internal static bool IsNullableRefType(FieldInfo field)
        {
            var n = new NullabilityInfoContext().Create(field);
            return n.ReadState == NullabilityState.Nullable;
        }

        /// <summary>
        /// Checks if is a Go primitive type, for example: int, string, bool.
        /// </summary>
        /// <param name="type">Type to check</param>
        /// <returns>return true if the type is a Go primitive type, otherwise
        /// false</returns>
        internal static bool IsGoPrimitiveType(Type type)
        {
            return type.IsPrimitive
                || type.IsEnum
                || type == typeof(string)
                || type == typeof(decimal);
        }

        /// <summary>
        /// Marshal a C# value to a C Interface struct.
        /// </summary>
        /// <param name="value">The value to marshal</param>
        /// <returns>The marshaled C Interface struct</returns>
        public static object CsValToCInterface(object value)
        {
            return CsToC(
                value switch
                {
                    int _ => new Interface { Type = 1, Integer = (int)value },
                    string _ => new Interface { Type = 3, String = (string)value },
                    double _ => new Interface { Type = 4, Float = (double)value },
                    float _ => new Interface { Type = 4, Float = (float)value },
                    long _ => new Interface { Type = 4, Float = (long)value },
                    short _ => new Interface { Type = 4, Float = (short)value },
                    bool _ => new Interface { Type = 5, Boolean = (bool)value },
                    _ => new Interface { Type = 0 },
                },
                new TypesC.Interface()
            );
        }

        /// <summary>
        /// Marshal a C# primitive value to an pointer.
        /// </summary>
        /// <param name="value">The value to marshal</param>
        /// <returns>Pointer to the marshaled value</returns>
        private static IntPtr MarshalPrimitiveValue(object value)
        {
            Type valueType = value.GetType();
            IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(valueType));
            switch (Type.GetTypeCode(valueType))
            {
                case TypeCode.Boolean:
                    Marshal.WriteByte(ptr, Convert.ToByte(value));
                    break;
                case TypeCode.Byte:
                    Marshal.WriteByte(ptr, (byte)value);
                    break;
                case TypeCode.Int16:
                case TypeCode.UInt16:
                    Marshal.WriteInt16(ptr, Convert.ToInt16(value));
                    break;
                case TypeCode.Int32:
                case TypeCode.UInt32:
                    Marshal.WriteInt32(ptr, Convert.ToInt32(value));
                    break;
                case TypeCode.Int64:
                case TypeCode.UInt64:
                    Marshal.WriteInt64(ptr, Convert.ToInt64(value));
                    break;
                case TypeCode.Single:
                case TypeCode.Double:
                    byte[] bytes =
                        valueType == typeof(float)
                            ? BitConverter.GetBytes((float)value)
                            : BitConverter.GetBytes((double)value);
                    Marshal.Copy(bytes, 0, ptr, bytes.Length);
                    break;
            }
            return ptr;
        }

        /// <summary>
        /// Unmarshal a pointer to a C primitive value to a C# primitive value.
        /// </summary>
        /// <param name="ptr">Pointer to the C primitive value</param>
        /// <param name="targetType">The target C# type</param>
        /// <returns>The unmarshaled C# primitive value</returns>
        /// <exception cref="NotSupportedException">Thrown if the target type is
        /// not supported</exception>
        /// <remarks>
        /// This function handles various primitive types including int, bool,
        /// double, float, long, short, byte, sbyte, uint, ulong, ushort, and
        /// string. If the pointer is null, it returns null.
        /// </remarks>
        public static object UnmarshalPrimitiveValue(IntPtr ptr, Type targetType)
        {
            if (ptr == IntPtr.Zero)
                return null;
            Type underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;
            return underlyingType switch
            {
                Type t when t == typeof(int) => Marshal.ReadInt32(ptr),
                Type t when t == typeof(bool) => Marshal.ReadByte(ptr) != 0,
                Type t when t == typeof(double) => Marshal.PtrToStructure<double>(ptr),
                Type t when t == typeof(float) => Marshal.PtrToStructure<float>(ptr),
                Type t when t == typeof(long) => Marshal.ReadInt64(ptr),
                Type t when t == typeof(short) => Marshal.ReadInt16(ptr),
                Type t when t == typeof(byte) => Marshal.ReadByte(ptr),
                Type t when t == typeof(uint) => (uint)Marshal.ReadInt32(ptr),
                Type t when t == typeof(ulong) => (ulong)Marshal.ReadInt64(ptr),
                Type t when t == typeof(ushort) => (ushort)Marshal.ReadInt16(ptr),
                _ => null,
            };
        }

        /// <summary>
        /// Convert a C instance to a C# instance by mapping fields to the
        /// corresponding fields in the C# instance.
        /// </summary>
        /// <param name="cInstance">The C-compatible struct instance to be
        /// converted.</param>
        /// <param name="csInstance">The C# instance to which the converted
        /// values will be assigned</param>
        /// <returns>The populated C# instance</returns>
        public static unsafe object CToCs(object cInstance, object csInstance)
        {
            if (cInstance == null)
                return null;

            foreach (
                var csField in csInstance
                    .GetType()
                    .GetFields(BindingFlags.Public | BindingFlags.Instance)
            )
            {
                var csFieldName = csField.Name;
                var cFieldName = csFieldName;
                var cField = cInstance.GetType().GetField(cFieldName);
                if (!IsNullableRefType(csField))
                {
                    if (IsGoPrimitiveType(csField.FieldType))
                    {
                        if (csField.FieldType == typeof(string))
                        {
                            var cVal = cField.GetValue(cInstance);
                            sbyte* ptr = (sbyte*)Pointer.Unbox(cVal);
                            string str = new(ptr);
                            if (!string.IsNullOrEmpty(str))
                            {
                                csField.SetValue(csInstance, str);
                            }
                        }
                        else
                        {
                            csField.SetValue(csInstance, cField.GetValue(cInstance));
                        }
                        continue;
                    }
                    else
                    {
                        // The Go struct, for example: excelize.Options, convert sub fields recursively
                        csField.SetValue(
                            csInstance,
                            CToCs(
                                cField.GetValue(cInstance),
                                Activator.CreateInstance(csField.FieldType)
                            )
                        );
                    }
                }
                else
                {
                    if (!csField.FieldType.IsArray)
                    {
                        // Pointer of the Go data type, for example: *excelize.Options or *string
                        if (cField != null)
                        {
                            if (
                                csField.FieldType == typeof(string)
                                || IsGoPrimitiveType(Nullable.GetUnderlyingType(csField.FieldType))
                            )
                            {
                                // Pointer of the Go basic data type, for example: *string
                                var cVal = cField.GetValue(cInstance);
                                if (csField.FieldType == typeof(string))
                                {
                                    sbyte** ptrPtr = (sbyte**)Pointer.Unbox(cVal);
                                    if (ptrPtr != null && *ptrPtr != null)
                                    {
                                        csField.SetValue(csInstance, new string(*ptrPtr));
                                    }
                                }
                                else
                                {
                                    IntPtr ptr = (IntPtr)Pointer.Unbox(cVal);
                                    if (ptr != IntPtr.Zero)
                                    {
                                        csField.SetValue(
                                            csInstance,
                                            UnmarshalPrimitiveValue(ptr, csField.FieldType)
                                        );
                                    }
                                }
                            }
                            else
                            {
                                // Pointer of the Go struct, for example: *excelize.Options
                                var cVal = cField.GetValue(cInstance);
                                var csType = Nullable.GetUnderlyingType(csField.FieldType);
                                if (cVal != null)
                                {
                                    IntPtr ptr = (IntPtr)Pointer.Unbox(cVal);
                                    if (ptr != IntPtr.Zero)
                                    {
                                        Type cStructType = Type.GetType(
                                            $"ExcelizeCs.TypesC.{csType.Name}"
                                        );
                                        object cStructInstance = Marshal.PtrToStructure(
                                            ptr,
                                            cStructType
                                        );
                                        csField.SetValue(
                                            csInstance,
                                            CToCs(cStructInstance, Activator.CreateInstance(csType))
                                        );
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // The Go data type array, for example:
                        // []*excelize.Options, []excelize.Options, []string, []*string
                        var n = new NullabilityInfoContext().Create(csField);
                        if (n.ElementType.ReadState == NullabilityState.NotNull)
                        {
                            // The Go data type array, for example: []excelize.Options or []string
                            var cVal = cField.GetValue(cInstance);
                            var l = Convert.ToInt32(
                                cInstance.GetType().GetField(cFieldName + "Len").GetValue(cInstance)
                            );
                            Array arr = Array.CreateInstance(csField.FieldType.GetElementType(), l);
                            if (l > 0)
                            {
                                if (IsGoPrimitiveType(csField.FieldType.GetElementType()))
                                {
                                    // The Go basic data type array, for example: []string
                                    if (csField.FieldType.GetElementType() == typeof(string))
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr strPtr = Marshal.ReadIntPtr(
                                                arrPtr,
                                                i * IntPtr.Size
                                            );
                                            arr.SetValue(Marshal.PtrToStringUTF8(strPtr), i);
                                        }
                                    }
                                    else
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr elePtr = IntPtr.Add(
                                                arrPtr,
                                                i * Marshal.SizeOf(typeof(int))
                                            );
                                            var val = UnmarshalPrimitiveValue(
                                                elePtr,
                                                csField.FieldType.GetElementType()
                                            );
                                            arr.SetValue(val, i);
                                        }
                                    }
                                }
                                else
                                {
                                    // The Go struct array, for example: []excelize.Options
                                    var csEleType = csField.FieldType.GetElementType();
                                    if (csEleType != null)
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        int structSize = Marshal.SizeOf(
                                            Type.GetType($"ExcelizeCs.TypesC.{csEleType.Name}")
                                        );
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr elePtr = IntPtr.Add(arrPtr, i * structSize);
                                            var cEle = Marshal.PtrToStructure(
                                                elePtr,
                                                Type.GetType($"ExcelizeCs.TypesC.{csEleType.Name}")
                                            );
                                            arr.SetValue(
                                                CToCs(cEle, Activator.CreateInstance(csEleType)),
                                                i
                                            );
                                        }
                                    }
                                }
                                csField.SetValue(csInstance, arr);
                            }
                        }
                        else
                        {
                            // Pointer array of the Go data type, for example:
                            // []*excelize.Options or []*string
                            var cVal = cField.GetValue(cInstance);
                            var l = Convert.ToInt32(
                                cInstance.GetType().GetField(cFieldName + "Len").GetValue(cInstance)
                            );
                            Type eleType = csField.FieldType.GetElementType();
                            Type underlyingType = Nullable.GetUnderlyingType(eleType) ?? eleType;
                            if (l > 0)
                            {
                                if (IsGoPrimitiveType(underlyingType))
                                {
                                    // Pointer array of the Go basic data type, for example: []*string
                                    Array arr = Array.CreateInstance(eleType, l);
                                    if (l > 0)
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr ptrToElement = Marshal.ReadIntPtr(
                                                arrPtr,
                                                i * IntPtr.Size
                                            );
                                            if (ptrToElement != IntPtr.Zero)
                                            {
                                                if (underlyingType == typeof(string))
                                                {
                                                    string strValue = Marshal.PtrToStringUTF8(
                                                        ptrToElement
                                                    );
                                                    arr.SetValue(strValue, i);
                                                }
                                                else
                                                {
                                                    object value = UnmarshalPrimitiveValue(
                                                        ptrToElement,
                                                        underlyingType
                                                    );
                                                    arr.SetValue(value, i);
                                                }
                                            }
                                            else
                                            {
                                                arr.SetValue(null, i);
                                            }
                                        }
                                    }
                                    csField.SetValue(csInstance, arr);
                                }
                                else
                                {
                                    // Pointer array of the Go struct, for example: []*excelize.Options
                                    Array arr = Array.CreateInstance(eleType, l);
                                    if (l > 0)
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr ptrToStruct = Marshal.ReadIntPtr(
                                                arrPtr,
                                                i * IntPtr.Size
                                            );
                                            if (ptrToStruct != IntPtr.Zero)
                                            {
                                                Type cStructType = Type.GetType(
                                                    $"ExcelizeCs.TypesC.{underlyingType.Name}"
                                                );
                                                object cStructInstance = Marshal.PtrToStructure(
                                                    ptrToStruct,
                                                    cStructType
                                                );
                                                object csStructInstance = Activator.CreateInstance(
                                                    underlyingType
                                                );
                                                object convertedStruct = CToCs(
                                                    cStructInstance,
                                                    csStructInstance
                                                );
                                                arr.SetValue(convertedStruct, i);
                                            }
                                            else
                                            {
                                                arr.SetValue(null, i);
                                            }
                                        }
                                    }
                                    csField.SetValue(csInstance, arr);
                                }
                            }
                        }
                    }
                }
            }
            return csInstance;
        }

        /// <summary>
        /// Converts a C# instance to a corresponding C instance.
        /// This function recursively converts fields of a C# instance to their
        /// corresponding C compatible struct instance and assigns them to the
        /// provided C instance.
        /// It handles primitive types, structs, pointers, and arrays.
        /// </summary>
        /// <param name="csInstance">The C# to be converted.</param>
        /// <param name="cInstance">The C-compatible struct instance to which
        /// the converted values will be assigned</param>
        /// <returns>The populated C-compatible struct instance</returns>
        public static object CsToC(object csInstance, object cInstance)
        {
            if (csInstance == null)
                return null;
            foreach (
                var csField in csInstance
                    .GetType()
                    .GetFields(BindingFlags.Public | BindingFlags.Instance)
            )
            {
                var csFieldName = csField.Name;
                var cFieldName = csFieldName;
                var cField = cInstance.GetType().GetField(cFieldName);
                if (csField.GetValue(csInstance) == null)
                    continue;
                if (!IsNullableRefType(csField))
                {
                    if (IsGoPrimitiveType(csField.FieldType))
                    {
                        if (csField.FieldType == typeof(string))
                        {
                            IntPtr ptr = Marshal.StringToCoTaskMemUTF8(
                                csField.GetValue(csInstance).ToString()
                            );
                            cField.SetValueDirect(__makeref(cInstance), ptr);
                        }
                        else
                        {
                            cField.SetValue(cInstance, csField.GetValue(csInstance));
                        }
                        continue;
                    }
                    else
                    {
                        // The Go struct, for example: excelize.Options, convert sub fields recursively
                        cField.SetValue(
                            cInstance,
                            CsToC(
                                csField.GetValue(csInstance),
                                Activator.CreateInstance(cField.FieldType)
                            )
                        );
                    }
                }
                else
                {
                    if (!csField.FieldType.IsArray)
                    {
                        // Pointer of the Go data type, for example: *excelize.Options or *string
                        if (
                            csField.FieldType == typeof(string)
                            || IsGoPrimitiveType(Nullable.GetUnderlyingType(csField.FieldType))
                        )
                        {
                            // Pointer of the Go basic data type, for example: *string
                            if (csField.FieldType == typeof(string))
                            {
                                IntPtr ptr = Marshal.StringToCoTaskMemUTF8(
                                    csField.GetValue(csInstance).ToString()
                                );
                                IntPtr ptrPtr = Marshal.AllocHGlobal(IntPtr.Size);
                                Marshal.WriteIntPtr(ptrPtr, ptr);
                                cField.SetValueDirect(__makeref(cInstance), ptrPtr);
                            }
                            else
                            {
                                cField.SetValue(
                                    cInstance,
                                    MarshalPrimitiveValue(csField.GetValue(csInstance))
                                );
                            }
                        }
                        else
                        {
                            // Pointer of the Go struct, for example: *excelize.Options
                            var cType = cField.FieldType.GetElementType();
                            IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(cType));
                            Marshal.StructureToPtr(
                                CsToC(
                                    csField.GetValue(csInstance),
                                    Activator.CreateInstance(cType)
                                ),
                                ptr,
                                false
                            );
                            cField.SetValue(cInstance, ptr);
                        }
                    }
                    else
                    {
                        // The Go data type array, for example:
                        // []*excelize.Options, []excelize.Options, []string, []*string
                        var n = new NullabilityInfoContext().Create(csField);
                        if (n.ElementType.ReadState == NullabilityState.NotNull)
                        {
                            // The Go data type array, for example: []excelize.Options or []string
                            Array list = (Array)csField.GetValue(csInstance);
                            int l = 0;
                            if (list != null)
                                l = list.Length;
                            var csEleType = csField.FieldType.GetElementType();
                            var cEleType = cField.FieldType.GetElementType();
                            Array arr = Array.CreateInstance(csEleType, l);
                            if (l > 0)
                            {
                                IntPtr arrPtr = IntPtr.Zero;
                                if (IsGoPrimitiveType(csEleType))
                                {
                                    // The Go basic data type array, for example: []string
                                    if (csEleType == typeof(string))
                                    {
                                        arrPtr = Marshal.AllocHGlobal(IntPtr.Size * l);
                                        for (int i = 0; i < l; i++)
                                        {
                                            var str = string.Empty;
                                            var val = list.GetValue(i);
                                            if (val != null)
                                                str = val.ToString();
                                            Marshal.WriteIntPtr(
                                                arrPtr,
                                                i * IntPtr.Size,
                                                Marshal.StringToCoTaskMemUTF8(str)
                                            );
                                        }
                                    }
                                    else
                                    {
                                        int size = Marshal.SizeOf(cEleType);
                                        arrPtr = Marshal.AllocHGlobal(size * l);
                                        for (int i = 0; i < l; i++)
                                        {
                                            Marshal.StructureToPtr(
                                                list.GetValue(i),
                                                arrPtr + (i * size),
                                                false
                                            );
                                        }
                                    }
                                }
                                else
                                {
                                    // The Go struct array, for example: []excelize.Options
                                    if (cEleType != null)
                                    {
                                        int size = Marshal.SizeOf(cEleType);
                                        arrPtr = Marshal.AllocHGlobal(size * l);
                                        for (int i = 0; i < l; i++)
                                        {
                                            var ele = list.GetValue(i);
                                            if (ele != null)
                                            {
                                                object cEle = Activator.CreateInstance(cEleType);
                                                object cVal = CsToC(ele, cEle);
                                                IntPtr elePtr = IntPtr.Add(arrPtr, i * size);
                                                Marshal.StructureToPtr(cVal, elePtr, false);
                                            }
                                        }
                                    }
                                }
                                cField.SetValue(cInstance, arrPtr);
                                var lenField = cInstance
                                    .GetType()
                                    .GetField(
                                        cFieldName + "Len",
                                        BindingFlags.Public | BindingFlags.Instance
                                    );
                                lenField.SetValue(cInstance, l);
                            }
                        }
                        else
                        {
                            // Pointer array of the Go data type, for example:
                            // []*excelize.Options or []*string
                            Array list = (Array)csField.GetValue(csInstance);
                            int l = 0;
                            if (list != null)
                                l = list.Length;
                            Type underlyingType =
                                Nullable.GetUnderlyingType(csField.FieldType.GetElementType())
                                ?? csField.FieldType.GetElementType();
                            if (l > 0)
                            {
                                IntPtr arrPtr = Marshal.AllocHGlobal(IntPtr.Size * l);
                                if (IsGoPrimitiveType(underlyingType))
                                {
                                    // Pointer array of the Go basic data type, for example: []*string
                                    for (int i = 0; i < l; i++)
                                    {
                                        IntPtr elePtr = IntPtr.Zero;
                                        var ele = list.GetValue(i);
                                        if (ele != null)
                                        {
                                            if (underlyingType == typeof(string))
                                            {
                                                elePtr = Marshal.StringToCoTaskMemUTF8(
                                                    ele.ToString()
                                                );
                                            }
                                            else
                                            {
                                                elePtr = MarshalPrimitiveValue(ele);
                                            }
                                        }
                                        Marshal.WriteIntPtr(arrPtr, i * IntPtr.Size, elePtr);
                                    }
                                }
                                else
                                {
                                    // Pointer array of the Go struct, for example: []*excelize.Options
                                    var cEleType = cField.FieldType.GetElementType();
                                    Type cEleUnderlyingType =
                                        Nullable.GetUnderlyingType(cEleType) ?? cEleType;
                                    if (cEleType != null)
                                    {
                                        for (int i = 0; i < l; i++)
                                        {
                                            var structPtr = IntPtr.Zero;
                                            var ele = list.GetValue(i);
                                            if (ele != null)
                                            {
                                                object cEle = Activator.CreateInstance(cEleType);
                                                object cVal = CsToC(ele, cEle);
                                                structPtr = Marshal.AllocHGlobal(
                                                    Marshal.SizeOf(cEleType)
                                                );
                                                Marshal.StructureToPtr(cVal, structPtr, false);
                                                Marshal.WriteIntPtr(
                                                    arrPtr,
                                                    i * IntPtr.Size,
                                                    structPtr
                                                );
                                            }
                                            Marshal.WriteIntPtr(arrPtr, i * IntPtr.Size, structPtr);
                                        }
                                    }
                                }
                                cField.SetValue(cInstance, arrPtr);
                                var lenField = cInstance
                                    .GetType()
                                    .GetField(
                                        cFieldName + "Len",
                                        BindingFlags.Public | BindingFlags.Instance
                                    );
                                lenField.SetValue(cInstance, l);
                            }
                        }
                    }
                }
            }
            return cInstance;
        }
    }

    public static class Excelize
    {
        /// <summary>
        /// STCellFormulaTypeArray defined the formula is an array formula.
        /// </summary>
        public const string STCellFormulaTypeArray = "array";

        /// <summary>
        /// STCellFormulaTypeDataTable defined the formula is a data table
        /// formula.
        /// </summary>
        public const string STCellFormulaTypeDataTable = "dataTable";

        /// <summary>
        /// STCellFormulaTypeNormal defined the formula is a regular cell
        /// formula.
        /// </summary>
        public const string STCellFormulaTypeNormal = "normal";

        /// <summary>
        /// STCellFormulaTypeShared defined the formula is part of a shared
        /// formula.
        /// </summary>
        public const string STCellFormulaTypeShared = "shared";

        /// <summary>
        /// Converts alphanumeric cell name to [X, Y] coordinates or returns an
        /// error.
        /// </summary>
        /// <param name="cell">The cell reference</param>
        /// <returns>Return a tuple containing the column number, row number if
        /// no error occurred</returns>
        /// <exception cref="RuntimeError">Raise a RuntimeError with the message
        /// if an error occurred</exception>
        public static unsafe (int, int) CellNameToCoordinates(string cell)
        {
            TypesC.CellNameToCoordinatesResult res = Lib.CellNameToCoordinates(cell);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return (res.col, res.row);
        }

        /// <summary>
        /// Convert Excel sheet column name (case-insensitive) to int. The
        /// function returns an error if column name incorrect.
        /// </summary>
        /// <param name="name">The column name</param>
        /// <returns>The column number as a integer</returns>
        /// <exception cref="RuntimeError">Raise a RuntimeError with the message
        /// if an error occurred</exception>
        public static unsafe int ColumnNameToNumber(string name)
        {
            TypesC.IntErrorResult res = Lib.ColumnNameToNumber(name);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return res.val;
        }

        /// <summary>
        /// Convert the integer to Excel sheet column title.
        /// </summary>
        /// <param name="num">The column number</param>
        /// <returns>The column name as a string</returns>
        /// <exception cref="RuntimeError">Raise a RuntimeError with the message
        /// if an error occurred</exception>
        public static unsafe string ColumnNumberToName(int num)
        {
            TypesC.StringErrorResult res = Lib.ColumnNumberToName(num);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new(res.val);
        }

        /// <summary>
        /// Converts [X, Y] coordinates to alpha-numeric cell name or returns
        /// an error.
        /// </summary>
        /// <param name="col">The column number</param>
        /// <param name="row">The row number</param>
        /// <param name="abs">Optional boolean indicating whether to use
        /// absolute references. If provided and True, the cell name will use
        /// absolute references (e.g., $A$1)</param>
        /// <returns>Return the cell name as a string if no error occurred,
        /// otherwise raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public static unsafe string CoordinatesToCellName(int col, int row, bool? abs = false)
        {
            TypesC.StringErrorResult res = Lib.CoordinatesToCellName(col, row, abs ?? false);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new(res.val);
        }

        /// <summary>
        /// Joins cell name from column name and row number.
        /// </summary>
        /// <param name="col">The column name</param>
        /// <param name="row">The row number</param>
        /// <returns>Return the cell name as a string if no error occurred,
        /// otherwise raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public static unsafe string JoinCellName(string col, int row)
        {
            TypesC.StringErrorResult res = Lib.JoinCellName(col, row);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new(res.val);
        }

        /// <summary>
        /// Splits cell name to column name and row number.
        /// </summary>
        /// <param name="cell">The cell reference</param>
        /// <returns>Return a tuple containing column name and row number if no
        /// error occurred, otherwise raise a RuntimeError with the message.
        /// </returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public static unsafe (string, int) SplitCellName(string cell)
        {
            TypesC.StringIntErrorResult res = Lib.SplitCellName(cell);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return (new string(res.strVal), res.intVal);
        }

        /// <summary>
        /// Create new file by default template.
        /// </summary>
        /// <returns>A populated spreadsheet file struct</returns>
        public static File NewFile()
        {
            return new File { FileIdx = Lib.NewFile() };
        }

        /// <summary>
        /// This function take the name of a spreadsheet file and returns a
        /// populated spreadsheet file struct for it.
        /// </summary>
        /// <param name="filename">The path to the Excel file to open</param>
        /// <param name="options">Optional parameters for opening file</param>
        /// <returns>Return a File object if if no error occurred, otherwise
        /// raise a RuntimeError with the message</returns>
        public static unsafe File OpenFile(string filename, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            var res = Lib.OpenFile(filename, ref opts);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new File { FileIdx = res.val };
        }

        /// <summary>
        /// Read data stream from bytes and return a populated spreadsheet file.
        /// </summary>
        /// <param name="buffer">The contents buffer of the file</param>
        /// <param name="options">Optional parameters for opening file</param>
        /// <returns>Return a File object if if no error occurred</returns>
        /// <exception cref="RuntimeError">Raise a RuntimeError with the message
        /// if an error occurred</exception>
        public static unsafe File OpenReader(byte[] buffer, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            var res = Lib.OpenReader(buffer, buffer.Length, ref opts);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new File { FileIdx = res.val };
        }
    }

    /// <summary>
    /// StreamWriter is a streaming writer for writing large amounts of data to
    /// a worksheet.
    /// </summary>
    public class StreamWriter
    {
        public long StreamWriterIdx { get; set; }

        public StreamWriter() { }

        public StreamWriter(long swIdx)
            : this()
        {
            StreamWriterIdx = swIdx;
        }

        /// <summary>
        /// Ending the streaming writing process.
        /// </summary>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe void Flush()
        {
            string err = Marshal.PtrToStringUTF8(Lib.StreamFlush(StreamWriterIdx));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Writes an array to stream rows by giving starting cell reference and
        /// a pointer to an array of values. Note that you must call the
        /// <c>Flush</c> function to end the streaming writing process.
        /// </summary>
        /// <param name="cell">The cell reference</param>
        /// <param name="values">The cell values</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetRow(string cell, List<object> values)
        {
            if (values == null || values.Count == 0)
                return;
            var arr = new TypesC.Interface[values.Count];
            for (int i = 0; i < values.Count; i++)
            {
                arr[i] = (TypesC.Interface)Lib.CsValToCInterface(values[i]);
            }
            string err = Marshal.PtrToStringUTF8(
                Lib.StreamSetRow(StreamWriterIdx, cell, arr, values.Count)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }
    }

    /// <summary>
    /// File is a representation of an workbook.
    /// </summary>
    public class File
    {
        public long FileIdx { get; set; }

        public File() { }

        public File(long fileIdx)
            : this()
        {
            FileIdx = fileIdx;
        }

        /// <summary>
        /// Add chart in a sheet by given chart format set (such as offset,
        /// scale, aspect ratio setting and print settings) and properties set.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="chart">Chart options</param>
        /// <param name="combo">Optional parameters for combo chart</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddChart(string sheet, string cell, Chart chart, params Chart[] combo)
        {
            var l = 1;
            if (combo != null && combo.Length > 0)
            {
                l += combo.Length;
            }
            var arr = new TypesC.Chart[l];
            arr[0] = (TypesC.Chart)Lib.CsToC(chart, new TypesC.Chart());
            if (combo != null && combo.Length > 0)
            {
                for (int i = 0; i < combo.Length; i++)
                {
                    arr[i + 1] = (TypesC.Chart)Lib.CsToC(combo[i], new TypesC.Chart());
                }
            }
            string err = Marshal.PtrToStringUTF8(
                Lib.AddChart(FileIdx, sheet, cell, arr, arr.Length)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Create a chartsheet by given chart format set (such as offset,
        /// scale, aspect ratio setting and print settings) and properties set.
        /// In Excel a chartsheet is a worksheet that only contains a chart.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="chart">Chart options</param>
        /// <param name="combo">Optional parameters for combo chart</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddChartSheet(string sheet, Chart chart, params Chart[] combo)
        {
            var l = 1;
            if (combo != null && combo.Length > 0)
            {
                l += combo.Length;
            }
            var arr = new TypesC.Chart[l];
            arr[0] = (TypesC.Chart)Lib.CsToC(chart, new TypesC.Chart());
            if (combo != null && combo.Length > 0)
            {
                for (int i = 0; i < combo.Length; i++)
                {
                    arr[i + 1] = (TypesC.Chart)Lib.CsToC(combo[i], new TypesC.Chart());
                }
            }
            string err = Marshal.PtrToStringUTF8(
                Lib.AddChartSheet(FileIdx, sheet, arr, arr.Length)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Add comments in a sheet by giving the worksheet name, cell
        /// reference, and format set (such as author and text). Note that the
        /// maximum author name length is 255 and the max text length is 32512.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The comment options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddComment(string sheet, Comment? options = null)
        {
            if (options == null)
                return;
            var opts = (TypesC.Comment)Lib.CsToC(options, new TypesC.Comment());
            string err = Marshal.PtrToStringUTF8(Lib.AddComment(FileIdx, sheet, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// AddFormControl provides the method to add form control object in a
        /// worksheet by given worksheet name and form control options.
        /// Supported form control type: button, check box, group box, label,
        /// option button, scroll bar and spinner. If set macro for the form
        /// control, the workbook extension should be XLSM or XLTM. Scroll value
        /// must be between 0 and 30000. Please note that if a cell link is set
        /// for a checkbox form control, Excelize will not assign a value to the
        /// linked cell when the checkbox is checked. To reflect the checkbox
        /// state, please use the <c>SetCellValue</c> function to manually set
        /// the linked cell's value to <c>true</c>.
        /// <example>
        /// Example 1, add button form control with macro, rich-text, custom
        /// button size, print property on Sheet1!A2, and let the button do not
        /// move or size with cells:
        /// <code>
        /// try
        /// {
        ///     f.AddFormControl(
        ///         "Sheet1",
        ///         new FormControl
        ///         {
        ///             Cell = "A2",
        ///             Macro = "Button1_Click",
        ///             Width = 140,
        ///             Height = 60,
        ///             Text = "Button 1\r\n",
        ///             Paragraph = new RichTextRun[]
        ///             {
        ///                 new()
        ///                 {
        ///                     Font = new Font
        ///                     {
        ///                         Bold = true,
        ///                         Italic = true,
        ///                         Underline = "single",
        ///                         Family = "Times New Roman",
        ///                         Size = 14,
        ///                         Color = "777777",
        ///                     },
        ///                     Text = "C1=A1+B1",
        ///                 },
        ///             },
        ///             Type = FormControlType.FormControlButton,
        ///             Format = new GraphicOptions
        ///             {
        ///                 PrintObject = true,
        ///                 Positioning = "absolute",
        ///             },
        ///         }
        ///     );
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// Example 2, add option button form control with checked status and
        /// text on Sheet1!A1:
        /// <code>
        /// try
        /// {
        ///     f.AddFormControl(
        ///         "Sheet1",
        ///         new FormControl
        ///         {
        ///             Cell = "A1",
        ///             Macro = "Button1_Click",
        ///             Text = "Option Button 1",
        ///             Type = FormControlType.FormControlOptionButton,
        ///         }
        ///     );
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// Example 3, add spin button form control on Sheet1!B1 to increase or
        /// decrease the value of Sheet1!A1:
        /// <code>
        /// try
        /// {
        ///     f.AddFormControl(
        ///         "Sheet1",
        ///         new FormControl
        ///         {
        ///             Cell = "B1",
        ///             Type = FormControlType.FormControlSpinButton,
        ///             Width = 15,
        ///             Height = 40,
        ///             CurrentVal = 7,
        ///             MinVal = 5,
        ///             MaxVal = 10,
        ///             IncChange = 1,
        ///             CellLink = "A1",
        ///         }
        ///     );
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// Example 4, add horizontally scroll bar form control on Sheet1!A2 to
        /// change the value of Sheet1!A1 by click the scroll arrows or drag
        /// the scroll box:
        /// <code>
        /// try
        /// {
        ///     f.AddFormControl(
        ///         "Sheet1",
        ///         new FormControl
        ///         {
        ///             Cell = "A2",
        ///             Type = FormControlType.FormControlScrollBar,
        ///             Width = 140,
        ///             Height = 20,
        ///             CurrentVal = 50,
        ///             MinVal = 10,
        ///             MaxVal = 100,
        ///             PageChange = 1,
        ///             CellLink = "A1",
        ///             Horizontally = true,
        ///         }
        ///     );
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The form control options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddFormControl(string sheet, FormControl? options = null)
        {
            if (options == null)
                return;
            var opts = (TypesC.FormControl)Lib.CsToC(options, new TypesC.FormControl());
            string err = Marshal.PtrToStringUTF8(Lib.AddFormControl(FileIdx, sheet, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set the graphics that can be referenced in the header and footer
        /// definitions via `&G`, supported image types: EMF, EMZ, GIF, ICO,
        /// JPEG, JPG, PNG, SVG, TIF, TIFF, WMF, and WMZ.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The header and footer image options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddHeaderFooterImage(string sheet, HeaderFooterImageOptions? options = null)
        {
            if (options == null)
                return;
            var opts = (TypesC.HeaderFooterImageOptions)
                Lib.CsToC(options, new TypesC.HeaderFooterImageOptions());
            string err = Marshal.PtrToStringUTF8(
                Lib.AddHeaderFooterImage(FileIdx, sheet, ref opts)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Ignored error for a range of cells.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="rangeRef">The cell range reference</param>
        /// <param name="ignoredErrorsType">The ignored errors type</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddIgnoredErrors(
            string sheet,
            string rangeRef,
            IgnoredErrorsType ignoredErrorsType
        )
        {
            string err = Marshal.PtrToStringUTF8(
                Lib.AddIgnoredErrors(FileIdx, sheet, rangeRef, (byte)ignoredErrorsType)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Add picture in a sheet by given picture format set (such as offset,
        /// scale, aspect ratio setting and print settings) and file path.
        /// Supported image types: GIF, JPEG, JPG, PNG, TIF and TIFF. Note that
        /// this function only supports adding pictures placed over the cells
        /// currently, and doesn't support adding pictures placed in cells or
        /// creating the Kingsoft WPS Office embedded image cells.
        /// <example>
        /// For example:
        /// <code>
        /// using ExcelizeCs;
        /// class Program
        /// {
        ///     static void Main()
        ///     {
        ///         ExcelizeCs.File? f;
        ///         try
        ///         {
        ///             f = Excelize.OpenFile("Book1.xlsx");
        ///         }
        ///         catch (RuntimeError err)
        ///         {
        ///             Console.WriteLine(err.Message);
        ///             return;
        ///         }
        ///         try
        ///         {
        ///             // Insert a picture.
        ///             f.AddPicture("Sheet1", "A1", "image.png", null);
        ///             // Insert a picture to worksheet with scaling.
        ///             f.AddPicture(
        ///                 "Sheet1",
        ///                 "A1",
        ///                 "image.jpg",
        ///                 new GraphicOptions
        ///                 {
        ///                     ScaleX = 0.1,
        ///                     ScaleY = 0.1,
        ///                 }
        ///             );
        ///             // Insert a picture offset in the cell with printing support.
        ///             f.AddPicture(
        ///                 "Sheet1",
        ///                 "A1",
        ///                 "image.jpg",
        ///                 new GraphicOptions
        ///                 {
        ///                     PrintObject = true,
        ///                     LockAspectRatio = false,
        ///                     OffsetX = 15,
        ///                     OffsetY = 10,
        ///                     Locked = false,
        ///                 }
        ///             );
        ///             // Save the spreadsheet with the origin path.
        ///             f.Save();
        ///         }
        ///         catch (RuntimeError err)
        ///         {
        ///             Console.WriteLine(err.Message);
        ///         }
        ///         finally
        ///         {
        ///             // Close the spreadsheet.
        ///             string err = f.Close();
        ///             if (!string.IsNullOrEmpty(err))
        ///                 Console.WriteLine(err);
        ///         }
        ///     }
        /// }
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="name">The image file path</param>
        /// <param name="options">The image options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddPicture(string sheet, string cell, string name, GraphicOptions? options)
        {
            var opts = (TypesC.GraphicOptions)
                Lib.CsToC(options ?? new GraphicOptions(), new TypesC.GraphicOptions());
            string err = Marshal.PtrToStringUTF8(
                Lib.AddPicture(FileIdx, sheet, cell, name, ref opts)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Add picture in a sheet by given picture format set (such as offset,
        /// scale, aspect ratio setting and print settings), file base name,
        /// extension name and file bytes. Supported image types:  GIF, JPEG,
        /// JPG, PNG, TIF and TIFF. Note that this function only supports adding
        /// pictures placed over the cells currently, and doesn't support adding
        /// pictures placed in cells or creating the Kingsoft WPS Office
        /// embedded image cells.
        /// <example>
        /// For example, insert a picture from bytes read from an image file:
        /// <code>
        /// using ExcelizeCs;
        ///
        /// class Program
        /// {
        ///     static void Main()
        ///     {
        ///         ExcelizeCs.File f = Excelize.NewFile();
        ///         try
        ///         {
        ///             f.AddPictureFromBytes(
        ///                 "Sheet1",
        ///                 "A2",
        ///                 new Picture
        ///                 {
        ///                     Extension = ".jpg",
        ///                     File = System.IO.File.ReadAllBytes("image.jpg"),
        ///                     Format = new GraphicOptions
        ///                     {
        ///                         PrintObject = true,
        ///                         ScaleX = 0.1,
        ///                         ScaleY = 0.1,
        ///                         Locked = false,
        ///                     },
        ///                     InsertType = PictureInsertType.PictureInsertTypePlaceOverCells,
        ///                 }
        ///             );
        ///             f.SaveAs("Book1.xlsx");
        ///         }
        ///         catch (RuntimeError err)
        ///         {
        ///             Console.WriteLine(err.Message);
        ///         }
        ///         finally
        ///         {
        ///             string err = f.Close();
        ///             if (!string.IsNullOrEmpty(err))
        ///                 Console.WriteLine(err);
        ///         }
        ///     }
        /// }
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="picture">The picture options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddPictureFromBytes(string sheet, string cell, Picture picture)
        {
            var pic = (TypesC.Picture)Lib.CsToC(picture, new TypesC.Picture());
            string err = Marshal.PtrToStringUTF8(
                Lib.AddPictureFromBytes(FileIdx, sheet, cell, ref pic)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// AddPivotTable provides the method to add pivot table by given pivot
        /// table options. Note that the same fields can not in Columns, Rows
        /// and Filter fields at the same time.
        /// <example>
        /// For example, create a pivot table on the range reference
        /// Sheet1!G2:M34 with the range reference Sheet1!A1:E31 as the data
        /// source, summarize by sum for sales:
        /// <code><![CDATA[
        /// using ExcelizeCs;
        ///
        /// class Program
        /// {
        ///     static void Main()
        ///     {
        ///         ExcelizeCs.File f = Excelize.NewFile();
        ///         List<string> months = new List<string>
        ///         {
        ///             "Jan",
        ///             "Feb",
        ///             "Mar",
        ///             "Apr",
        ///             "May",
        ///             "Jun",
        ///             "Jul",
        ///             "Aug",
        ///             "Sep",
        ///             "Oct",
        ///             "Nov",
        ///             "Dec",
        ///         };
        ///         List<int> year = new List<int> { 2017, 2018, 2019 };
        ///         List<string> types = new List<string> { "Meat", "Dairy", "Beverages", "Produce" };
        ///         List<string> region = new List<string> { "East", "West", "North", "South" };
        ///         Random random = new Random();
        ///         try
        ///         {
        ///             f.SetSheetRow(
        ///                 "Sheet1",
        ///                 "A1",
        ///                 new List<object> { "Month", "Year", "Type", "Sales", "Region" }
        ///             );
        ///             for (int row = 2; row < 32; row++)
        ///             {
        ///                 f.SetCellValue(
        ///                     "Sheet1",
        ///                     Excelize.CoordinatesToCellName(1, row),
        ///                     months[random.Next(12)]
        ///                 );
        ///                 f.SetCellValue(
        ///                     "Sheet1",
        ///                     Excelize.CoordinatesToCellName(2, row),
        ///                     year[random.Next(3)]
        ///                 );
        ///                 f.SetCellValue(
        ///                     "Sheet1",
        ///                     Excelize.CoordinatesToCellName(3, row),
        ///                     types[random.Next(4)]
        ///                 );
        ///                 f.SetCellValue("Sheet1", Excelize.CoordinatesToCellName(4, row), random.Next(5000));
        ///                 f.SetCellValue(
        ///                     "Sheet1",
        ///                     Excelize.CoordinatesToCellName(5, row),
        ///                     region[random.Next(4)]
        ///                 );
        ///             }
        ///             f.AddPivotTable(
        ///                 new PivotTableOptions
        ///                 {
        ///                     DataRange = "Sheet1!A1:E31",
        ///                     PivotTableRange = "Sheet1!G2:M34",
        ///                     Rows = new PivotTableField[]
        ///                     {
        ///                         new() { Data = "Month", DefaultSubtotal = true },
        ///                         new() { Data = "Year" },
        ///                     },
        ///                     Filter = new PivotTableField[] { new() { Data = "Region" } },
        ///                     Columns = new PivotTableField[]
        ///                     {
        ///                         new() { Data = "Type", DefaultSubtotal = true },
        ///                     },
        ///                     Data = new PivotTableField[]
        ///                     {
        ///                         new()
        ///                         {
        ///                             Data = "Sales",
        ///                             Name = "Summarize",
        ///                             Subtotal = "sum",
        ///                         },
        ///                     },
        ///                     RowGrandTotals = true,
        ///                     ColGrandTotals = true,
        ///                     ShowDrill = true,
        ///                     ShowRowHeaders = true,
        ///                     ShowColHeaders = true,
        ///                     ShowLastColumn = true,
        ///                 }
        ///             );
        ///             f.SaveAs("Book1.xlsx");
        ///         }
        ///         catch (RuntimeError err)
        ///         {
        ///             Console.WriteLine(err.Message);
        ///         }
        ///         finally
        ///         {
        ///             string err = f.Close();
        ///             if (!string.IsNullOrEmpty(err))
        ///                 Console.WriteLine(err);
        ///         }
        ///     }
        /// }]]>
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="options">The pivot table options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddPivotTable(PivotTableOptions options)
        {
            var opts = (TypesC.PivotTableOptions)Lib.CsToC(options, new TypesC.PivotTableOptions());
            string err = Marshal.PtrToStringUTF8(Lib.AddPivotTable(FileIdx, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// AddShape provides the method to add shape in a sheet by given
        /// worksheet name and shape format set (such as offset, scale, aspect
        /// ratio setting and print settings). The following shows the type of
        /// shape supported by excelize:
        /// <list type="table">
        ///     <listheader>
        ///         <term>Type</term>
        ///         <description>Shape</description>
        ///     </listheader>
        ///     <item><term>accentBorderCallout1</term><description>Callout 1 with Border and Accent Shape</description></item>
        ///     <item><term>accentBorderCallout2</term><description>Callout 2 with Border and Accent Shape</description></item>
        ///     <item><term>accentBorderCallout3</term><description>Callout 3 with Border and Accent Shape</description></item>
        ///     <item><term>accentCallout1</term><description>Callout 1 Shape</description></item>
        ///     <item><term>accentCallout2</term><description>Callout 2 Shape</description></item>
        ///     <item><term>accentCallout3</term><description>Callout 3 Shape</description></item>
        ///     <item><term>actionButtonBackPrevious</term><description>Back or Previous Button Shape</description></item>
        ///     <item><term>actionButtonBeginning</term><description>Beginning Button Shape</description></item>
        ///     <item><term>actionButtonBlank</term><description>Blank Button Shape</description></item>
        ///     <item><term>actionButtonDocument</term><description>Document Button Shape</description></item>
        ///     <item><term>actionButtonEnd</term><description>End Button Shape</description></item>
        ///     <item><term>actionButtonForwardNext</term><description>Forward or Next Button Shape</description></item>
        ///     <item><term>actionButtonHelp</term><description>Help Button Shape</description></item>
        ///     <item><term>actionButtonHome</term><description>Home Button Shape</description></item>
        ///     <item><term>actionButtonInformation</term><description>Information Button Shape</description></item>
        ///     <item><term>actionButtonMovie</term><description>Movie Button Shape</description></item>
        ///     <item><term>actionButtonReturn</term><description>Return Button Shape</description></item>
        ///     <item><term>actionButtonSound</term><description>Sound Button Shape</description></item>
        ///     <item><term>arc</term><description>Curved Arc Shape</description></item>
        ///     <item><term>bentArrow</term><description>Bent Arrow Shape</description></item>
        ///     <item><term>bentConnector2</term><description>Bent Connector 2 Shape</description></item>
        ///     <item><term>bentConnector3</term><description>Bent Connector 3 Shape</description></item>
        ///     <item><term>bentConnector4</term><description>Bent Connector 4 Shape</description></item>
        ///     <item><term>bentConnector5</term><description>Bent Connector 5 Shape</description></item>
        ///     <item><term>bentUpArrow</term><description>Bent Up Arrow Shape</description></item>
        ///     <item><term>bevel</term><description>Bevel Shape</description></item>
        ///     <item><term>blockArc</term><description>Block Arc Shape</description></item>
        ///     <item><term>borderCallout1</term><description>Callout 1 with Border Shape</description></item>
        ///     <item><term>borderCallout2</term><description>Callout 2 with Border Shape</description></item>
        ///     <item><term>borderCallout3</term><description>Callout 3 with Border Shape</description></item>
        ///     <item><term>bracePair</term><description>Brace Pair Shape</description></item>
        ///     <item><term>bracketPair</term><description>Bracket Pair Shape</description></item>
        ///     <item><term>callout1</term><description>Callout 1 Shape</description></item>
        ///     <item><term>callout2</term><description>Callout 2 Shape</description></item>
        ///     <item><term>callout3</term><description>Callout 3 Shape</description></item>
        ///     <item><term>can</term><description>Can Shape</description></item>
        ///     <item><term>chartPlus</term><description>Chart Plus Shape</description></item>
        ///     <item><term>chartStar</term><description>Chart Star Shape</description></item>
        ///     <item><term>chartX</term><description>Chart X Shape</description></item>
        ///     <item><term>chevron</term><description>Chevron Shape</description></item>
        ///     <item><term>chord</term><description>Chord Shape</description></item>
        ///     <item><term>circularArrow</term><description>Circular Arrow Shape</description></item>
        ///     <item><term>cloud</term><description>Cloud Shape</description></item>
        ///     <item><term>cloudCallout</term><description>Callout Cloud Shape</description></item>
        ///     <item><term>corner</term><description>Corner Shape</description></item>
        ///     <item><term>cornerTabs</term><description>Corner Tabs Shape</description></item>
        ///     <item><term>cube</term><description>Cube Shape</description></item>
        ///     <item><term>curvedConnector2</term><description>Curved Connector 2 Shape</description></item>
        ///     <item><term>curvedConnector3</term><description>Curved Connector 3 Shape</description></item>
        ///     <item><term>curvedConnector4</term><description>Curved Connector 4 Shape</description></item>
        ///     <item><term>curvedConnector5</term><description>Curved Connector 5 Shape</description></item>
        ///     <item><term>curvedDownArrow</term><description>Curved Down Arrow Shape</description></item>
        ///     <item><term>curvedLeftArrow</term><description>Curved Left Arrow Shape</description></item>
        ///     <item><term>curvedRightArrow</term><description>Curved Right Arrow Shape</description></item>
        ///     <item><term>curvedUpArrow</term><description>Curved Up Arrow Shape</description></item>
        ///     <item><term>decagon</term><description>Decagon Shape</description></item>
        ///     <item><term>diagStripe</term><description>Diagonal Stripe Shape</description></item>
        ///     <item><term>diamond</term><description>Diamond Shape</description></item>
        ///     <item><term>dodecagon</term><description>Dodecagon Shape</description></item>
        ///     <item><term>donut</term><description>Donut Shape</description></item>
        ///     <item><term>doubleWave</term><description>Double Wave Shape</description></item>
        ///     <item><term>downArrow</term><description>Down Arrow Shape</description></item>
        ///     <item><term>downArrowCallout</term><description>Callout Down Arrow Shape</description></item>
        ///     <item><term>ellipse</term><description>Ellipse Shape</description></item>
        ///     <item><term>ellipseRibbon</term><description>Ellipse Ribbon Shape</description></item>
        ///     <item><term>ellipseRibbon2</term><description>Ellipse Ribbon 2 Shape</description></item>
        ///     <item><term>flowChartAlternateProcess</term><description>Alternate Process Flow Shape</description></item>
        ///     <item><term>flowChartCollate</term><description>Collate Flow Shape</description></item>
        ///     <item><term>flowChartConnector</term><description>Connector Flow Shape</description></item>
        ///     <item><term>flowChartDecision</term><description>Decision Flow Shape</description></item>
        ///     <item><term>flowChartDelay</term><description>Delay Flow Shape</description></item>
        ///     <item><term>flowChartDisplay</term><description>Display Flow Shape</description></item>
        ///     <item><term>flowChartDocument</term><description>Document Flow Shape</description></item>
        ///     <item><term>flowChartExtract</term><description>Extract Flow Shape</description></item>
        ///     <item><term>flowChartInputOutput</term><description>Input Output Flow Shape</description></item>
        ///     <item><term>flowChartInternalStorage</term><description>Internal Storage Flow Shape</description></item>
        ///     <item><term>flowChartMagneticDisk</term><description>Magnetic Disk Flow Shape</description></item>
        ///     <item><term>flowChartMagneticDrum</term><description>Magnetic Drum Flow Shape</description></item>
        ///     <item><term>flowChartMagneticTape</term><description>Magnetic Tape Flow Shape</description></item>
        ///     <item><term>flowChartManualInput</term><description>Manual Input Flow Shape</description></item>
        ///     <item><term>flowChartManualOperation</term><description>Manual Operation Flow Shape</description></item>
        ///     <item><term>flowChartMerge</term><description>Merge Flow Shape</description></item>
        ///     <item><term>flowChartMultidocument</term><description>Multi-Document Flow Shape</description></item>
        ///     <item><term>flowChartOfflineStorage</term><description>Offline Storage Flow Shape</description></item>
        ///     <item><term>flowChartOffpageConnector</term><description>Off-Page Connector Flow Shape</description></item>
        ///     <item><term>flowChartOnlineStorage</term><description>Online Storage Flow Shape</description></item>
        ///     <item><term>flowChartOr</term><description>Or Flow Shape</description></item>
        ///     <item><term>flowChartPredefinedProcess</term><description>Predefined Process Flow Shape</description></item>
        ///     <item><term>flowChartPreparation</term><description>Preparation Flow Shape</description></item>
        ///     <item><term>flowChartProcess</term><description>Process Flow Shape</description></item>
        ///     <item><term>flowChartPunchedCard</term><description>Punched Card Flow Shape</description></item>
        ///     <item><term>flowChartPunchedTape</term><description>Punched Tape Flow Shape</description></item>
        ///     <item><term>flowChartSort</term><description>Sort Flow Shape</description></item>
        ///     <item><term>flowChartSummingJunction</term><description>Summing Junction Flow Shape</description></item>
        ///     <item><term>flowChartTerminator</term><description>Terminator Flow Shape</description></item>
        ///     <item><term>foldedCorner</term><description>Folded Corner Shape</description></item>
        ///     <item><term>frame</term><description>Frame Shape</description></item>
        ///     <item><term>funnel</term><description>Funnel Shape</description></item>
        ///     <item><term>gear6</term><description>Gear 6 Shape</description></item>
        ///     <item><term>gear9</term><description>Gear 9 Shape</description></item>
        ///     <item><term>halfFrame</term><description>Half Frame Shape</description></item>
        ///     <item><term>heart</term><description>Heart Shape</description></item>
        ///     <item><term>heptagon</term><description>Heptagon Shape</description></item>
        ///     <item><term>hexagon</term><description>Hexagon Shape</description></item>
        ///     <item><term>homePlate</term><description>Home Plate Shape</description></item>
        ///     <item><term>horizontalScroll</term><description>Horizontal Scroll Shape</description></item>
        ///     <item><term>irregularSeal1</term><description>Irregular Seal 1 Shape</description></item>
        ///     <item><term>irregularSeal2</term><description>Irregular Seal 2 Shape</description></item>
        ///     <item><term>leftArrow</term><description>Left Arrow Shape</description></item>
        ///     <item><term>leftArrowCallout</term><description>Callout Left Arrow Shape</description></item>
        ///     <item><term>leftBrace</term><description>Left Brace Shape</description></item>
        ///     <item><term>leftBracket</term><description>Left Bracket Shape</description></item>
        ///     <item><term>leftCircularArrow</term><description>Left Circular Arrow Shape</description></item>
        ///     <item><term>leftRightArrow</term><description>Left Right Arrow Shape</description></item>
        ///     <item><term>leftRightArrowCallout</term><description>Callout Left Right Arrow Shape</description></item>
        ///     <item><term>leftRightCircularArrow</term><description>Left Right Circular Arrow Shape</description></item>
        ///     <item><term>leftRightRibbon</term><description>Left Right Ribbon Shape</description></item>
        ///     <item><term>leftRightUpArrow</term><description>Left Right Up Arrow Shape</description></item>
        ///     <item><term>leftUpArrow</term><description>Left Up Arrow Shape</description></item>
        ///     <item><term>lightningBolt</term><description>Lightning Bolt Shape</description></item>
        ///     <item><term>line</term><description>Line Shape</description></item>
        ///     <item><term>lineInv</term><description>Line Inverse Shape</description></item>
        ///     <item><term>mathDivide</term><description>Divide Math Shape</description></item>
        ///     <item><term>mathEqual</term><description>Equal Math Shape</description></item>
        ///     <item><term>mathMinus</term><description>Minus Math Shape</description></item>
        ///     <item><term>mathMultiply</term><description>Multiply Math Shape</description></item>
        ///     <item><term>mathNotEqual</term><description>Not Equal Math Shape</description></item>
        ///     <item><term>mathPlus</term><description>Plus Math Shape</description></item>
        ///     <item><term>moon</term><description>Moon Shape</description></item>
        ///     <item><term>nonIsoscelesTrapezoid</term><description>Non-Isosceles Trapezoid Shape</description></item>
        ///     <item><term>noSmoking</term><description>No Smoking Shape</description></item>
        ///     <item><term>notchedRightArrow</term><description>Notched Right Arrow Shape</description></item>
        ///     <item><term>octagon</term><description>Octagon Shape</description></item>
        ///     <item><term>parallelogram</term><description>Parallelogram Shape</description></item>
        ///     <item><term>pentagon</term><description>Pentagon Shape</description></item>
        ///     <item><term>pie</term><description>Pie Shape</description></item>
        ///     <item><term>pieWedge</term><description>Pie Wedge Shape</description></item>
        ///     <item><term>plaque</term><description>Plaque Shape</description></item>
        ///     <item><term>plaqueTabs</term><description>Plaque Tabs Shape</description></item>
        ///     <item><term>plus</term><description>Plus Shape</description></item>
        ///     <item><term>quadArrow</term><description>Quad-Arrow Shape</description></item>
        ///     <item><term>quadArrowCallout</term><description>Callout Quad-Arrow Shape</description></item>
        ///     <item><term>rect</term><description>Rectangle Shape</description></item>
        ///     <item><term>ribbon</term><description>Ribbon Shape</description></item>
        ///     <item><term>ribbon2</term><description>Ribbon 2 Shape</description></item>
        ///     <item><term>rightArrow</term><description>Right Arrow Shape</description></item>
        ///     <item><term>rightArrowCallout</term><description>Callout Right Arrow Shape</description></item>
        ///     <item><term>rightBrace</term><description>Right Brace Shape</description></item>
        ///     <item><term>rightBracket</term><description>Right Bracket Shape</description></item>
        ///     <item><term>round1Rect</term><description>One Round Corner Rectangle Shape</description></item>
        ///     <item><term>round2DiagRect</term><description>Two Diagonal Round Corner Rectangle Shape</description></item>
        ///     <item><term>round2SameRect</term><description>Two Same-side Round Corner Rectangle Shape</description></item>
        ///     <item><term>roundRect</term><description>Round Corner Rectangle Shape</description></item>
        ///     <item><term>rtTriangle</term><description>Right Triangle Shape</description></item>
        ///     <item><term>smileyFace</term><description>Smiley Face Shape</description></item>
        ///     <item><term>snip1Rect</term><description>One Snip Corner Rectangle Shape</description></item>
        ///     <item><term>snip2DiagRect</term><description>Two Diagonal Snip Corner Rectangle Shape</description></item>
        ///     <item><term>snip2SameRect</term><description>Two Same-side Snip Corner Rectangle Shape</description></item>
        ///     <item><term>snipRoundRect</term><description>One Snip One Round Corner Rectangle Shape</description></item>
        ///     <item><term>squareTabs</term><description>Square Tabs Shape</description></item>
        ///     <item><term>star10</term><description>Ten Pointed Star Shape</description></item>
        ///     <item><term>star12</term><description>Twelve Pointed Star Shape</description></item>
        ///     <item><term>star16</term><description>Sixteen Pointed Star Shape</description></item>
        ///     <item><term>star24</term><description>Twenty Four Pointed Star Shape</description></item>
        ///     <item><term>star32</term><description>Thirty Two Pointed Star Shape</description></item>
        ///     <item><term>star4</term><description>Four Pointed Star Shape</description></item>
        ///     <item><term>star5</term><description>Five Pointed Star Shape</description></item>
        ///     <item><term>star6</term><description>Six Pointed Star Shape</description></item>
        ///     <item><term>star7</term><description>Seven Pointed Star Shape</description></item>
        ///     <item><term>star8</term><description>Eight Pointed Star Shape</description></item>
        ///     <item><term>straightConnector1</term><description>Straight Connector 1 Shape</description></item>
        ///     <item><term>stripedRightArrow</term><description>Striped Right Arrow Shape</description></item>
        ///     <item><term>sun</term><description>Sun Shape</description></item>
        ///     <item><term>swooshArrow</term><description>Swoosh Arrow Shape</description></item>
        ///     <item><term>teardrop</term><description>Teardrop Shape</description></item>
        ///     <item><term>trapezoid</term><description>Trapezoid Shape</description></item>
        ///     <item><term>triangle</term><description>Triangle Shape</description></item>
        ///     <item><term>upArrow</term><description>Up Arrow Shape</description></item>
        ///     <item><term>upArrowCallout</term><description>Callout Up Arrow Shape</description></item>
        ///     <item><term>upDownArrow</term><description>Up Down Arrow Shape</description></item>
        ///     <item><term>upDownArrowCallout</term><description>Callout Up Down Arrow Shape</description></item>
        ///     <item><term>uturnArrow</term><description>U-Turn Arrow Shape</description></item>
        ///     <item><term>verticalScroll</term><description>Vertical Scroll Shape</description></item>
        ///     <item><term>wave</term><description>Wave Shape</description></item>
        ///     <item><term>wedgeEllipseCallout</term><description>Callout Wedge Ellipse Shape</description></item>
        ///     <item><term>wedgeRectCallout</term><description>Callout Wedge Rectangle Shape</description></item>
        ///     <item><term>wedgeRoundRectCallout</term><description>Callout Wedge Round Rectangle Shape</description></item>
        /// </list>
        /// The following shows the type of text underline supported by excelize:
        /// <list type="bullet">
        ///     <listheader>
        ///         <term>Type</term>
        ///     </listheader>
        ///     <item><term>none</term></item>
        ///     <item><term>words</term></item>
        ///     <item><term>sng</term></item>
        ///     <item><term>dbl</term></item>
        ///     <item><term>heavy</term></item>
        ///     <item><term>dotted</term></item>
        ///     <item><term>dottedHeavy</term></item>
        ///     <item><term>dash</term></item>
        ///     <item><term>dashHeavy</term></item>
        ///     <item><term>dashLong</term></item>
        ///     <item><term>dashLongHeavy</term></item>
        ///     <item><term>dotDash</term></item>
        ///     <item><term>dotDashHeavy</term></item>
        ///     <item><term>dotDotDash</term></item>
        ///     <item><term>dotDotDashHeavy</term></item>
        ///     <item><term>wavy</term></item>
        ///     <item><term>wavyHeavy</term></item>
        ///     <item><term>wavyDbl</term></item>
        /// </list>
        /// <example>
        /// For example, add text box (rect shape) in Sheet1:
        /// <code>
        /// using ExcelizeCs;
        ///
        /// class Program
        /// {
        ///     static void Main()
        ///     {
        ///         ExcelizeCs.File f = Excelize.NewFile();
        ///         try
        ///         {
        ///             f.AddShape(
        ///                 "Sheet1",
        ///                 new Shape
        ///                 {
        ///                     Cell = "G6",
        ///                     Type = "rect",
        ///                     Line = new ShapeLine { Color = "4286F4", Width = 1.2 },
        ///                     Fill = new Fill { Color = new string[] { "8EB9FF" }, Pattern = 1 },
        ///                     Paragraph = new RichTextRun[]
        ///                     {
        ///                         new()
        ///                         {
        ///                             Text = "Rectangle Shape",
        ///                             Font = new Font
        ///                             {
        ///                                 Bold = true,
        ///                                 Italic = true,
        ///                                 Family = "Times New Roman",
        ///                                 Size = 19,
        ///                                 Color = "777777",
        ///                                 Underline = "sng",
        ///                             },
        ///                         },
        ///                     },
        ///                     Width = 180,
        ///                     Height = 40,
        ///                 }
        ///             );
        ///             f.SaveAs("Book1.xlsx");
        ///         }
        ///         catch (RuntimeError err)
        ///         {
        ///             Console.WriteLine(err.Message);
        ///         }
        ///         finally
        ///         {
        ///             string err = f.Close();
        ///             if (!string.IsNullOrEmpty(err))
        ///                 Console.WriteLine(err);
        ///         }
        ///     }
        /// }
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The shape options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddShape(string sheet, Shape options)
        {
            var opts = (TypesC.Shape)Lib.CsToC(options, new TypesC.Shape());
            string err = Marshal.PtrToStringUTF8(Lib.AddShape(FileIdx, sheet, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// AddSlicer function inserts a slicer by giving the worksheet name and
        /// slicer settings.
        /// <example>
        /// For example, insert a slicer on the <c>Sheet1!E1</c> with field
        /// <c>Column1</c> for the table named <c>Table1</c>:
        /// <code>
        /// f.AddSlicer(
        ///     "Sheet1",
        ///     new SlicerOptions
        ///     {
        ///         Name = "Column1",
        ///         Cell = "E1",
        ///         TableSheet = "Sheet1",
        ///         TableName = "Table1",
        ///         Caption = "Column1",
        ///         Width = 200,
        ///         Height = 200,
        ///     }
        /// );
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The slicer options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddSlicer(string sheet, SlicerOptions options)
        {
            var opts = (TypesC.SlicerOptions)Lib.CsToC(options, new TypesC.SlicerOptions());
            string err = Marshal.PtrToStringUTF8(Lib.AddSlicer(FileIdx, sheet, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// AddSparkline provides a function to add sparklines to the worksheet
        /// by given formatting options. Sparklines are small charts that fit in
        /// a single cell and are used to show trends in data. Sparklines are a
        /// feature of Excel 2010 and later only. You can write them to workbook
        /// that can be read by Excel 2007, but they won't be displayed.
        /// <example>
        /// For example, add a grouped sparkline. Changes are applied to all
        /// three:
        /// <code>
        /// f.AddSparkline(
        ///     "Sheet1",
        ///     new SparklineOptions
        ///     {
        ///         Location = new string[] { "A1", "A2", "A3" },
        ///         Range = new string[] { "Sheet2!A1:J1", "Sheet2!A2:J2", "Sheet2!A3:J3" },
        ///         Markers = true,
        ///     }
        /// );
        /// </code>
        /// </example>
        /// The following shows the formatting options of sparkline supported by
        /// excelize:
        /// <list type="table">
        ///     <listheader>
        ///         <term>Parameter</term>
        ///         <description>Description</description>
        ///     </listheader>
        ///     <item>
        ///         <term>Location</term>
        ///         <description>Required â€” must have the same number as the
        ///         <c>Range</c> parameter.</description>
        ///     </item>
        ///     <item>
        ///         <term>Range</term>
        ///         <description>Required â€” must have the same number as the
        ///         <c>Location</c> parameter.</description>
        ///     </item>
        ///     <item>
        ///         <term>Type</term>
        ///         <description>Enumeration value: <c>line</c>, <c>column</c>,
        ///         <c>win_loss</c>.</description>
        ///     </item>
        ///     <item>
        ///         <term>Style</term>
        ///         <description>Value range: 0â€“35.</description>
        ///     </item>
        ///     <item>
        ///         <term>Hight</term>
        ///         <description>Toggle sparkline high points.</description>
        ///     </item>
        ///     <item>
        ///         <term>Low</term>
        ///         <description>Toggle sparkline low points.</description>
        ///     </item>
        ///     <item>
        ///         <term>First</term>
        ///         <description>Toggle sparkline first points.</description>
        ///     </item>
        ///     <item>
        ///         <term>Last</term>
        ///         <description>Toggle sparkline last points.</description>
        ///     </item>
        ///     <item>
        ///         <term>Negative</term>
        ///         <description>Toggle sparkline negative points.</description>
        ///     </item>
        ///     <item>
        ///         <term>Markers</term>
        ///         <description>Toggle sparkline markers.</description>
        ///     </item>
        ///     <item>
        ///         <term>Axis</term>
        ///         <description>Specifies whether to show the horizontal axis.</description>
        ///     </item>
        ///     <item>
        ///         <term>Reverse</term>
        ///         <description>Specifies whether to plot data right-to-left.</description>
        ///     </item>
        ///     <item>
        ///         <term>SeriesColor</term>
        ///         <description>An RGB color specified as <c>RRGGBB</c>.</description>
        ///     </item>
        /// </list>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The sparklines options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddSparkline(string sheet, SparklineOptions options)
        {
            var opts = (TypesC.SparklineOptions)Lib.CsToC(options, new TypesC.SparklineOptions());
            string err = Marshal.PtrToStringUTF8(Lib.AddSparkline(FileIdx, sheet, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Adds a table to a worksheet using the specified worksheet name,
        /// range reference, and format settings.
        /// <example>
        /// Create a table on Sheet1 for the range A1:D5:
        /// <code>
        /// f.AddTable("Sheet1", new Table { Range = "A1:D5" });
        /// </code>
        /// Create a table on Sheet2 for the range F2:H6 with formatting:
        /// <code>
        /// f.AddTable(
        ///     "Sheet2",
        ///     new Table
        ///     {
        ///         Range = "F2:H6",
        ///         Name = "table",
        ///         StyleName = "TableStyleMedium2",
        ///         ShowFirstColumn = true,
        ///         ShowLastColumn = true,
        ///         ShowRowStripes = false,
        ///         ShowColumnStripes = true,
        ///     }
        /// );
        /// </code>
        /// </example>
        /// </summary>
        /// <remarks>
        /// The table must include at least two rows, including a header row.
        /// Header cells must contain unique string values.
        /// Set the header row data before calling <c>AddTable</c>.
        /// Table ranges within the same worksheet must not intersect.
        ///
        /// <para><b>Name:</b> The name of the table must be unique within the
        /// worksheet, begin with a letter or underscore, contain no spaces or
        /// special characters, and be no more than 255 characters long.</para>
        ///
        /// <para><b>StyleName:</b> Valid built-in table style names include:</para>
        /// <list type="bullet">
        ///   <item><description>TableStyleLight1 â€“ TableStyleLight21</description></item>
        ///   <item><description>TableStyleMedium1 â€“ TableStyleMedium28</description></item>
        ///   <item><description>TableStyleDark1 â€“ TableStyleDark11</description></item>
        /// </list>
        /// </remarks>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The table options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddTable(string sheet, Table options)
        {
            var opts = (TypesC.Table)Lib.CsToC(options, new TypesC.Table());
            string err = Marshal.PtrToStringUTF8(Lib.AddTable(FileIdx, sheet, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Add vbaProject.bin file which contains functions and/or macros. The
        /// file extension should be XLSM or XLTM.
        /// </summary>
        /// <param name="buffer">The contents buffer of the file</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddVBAProject(byte[] buffer)
        {
            string err = Marshal.PtrToStringUTF8(Lib.AddVBAProject(FileIdx, buffer, buffer.Length));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Adds an auto filter to a worksheet using the specified sheet name,
        /// range reference, and filter options.
        ///
        /// An auto filter in Excel provides a way to filter a 2D range of data
        /// based on simple criteria. For example, to apply an auto filter to
        /// the range <c>A1:D4</c> on the worksheet "Sheet1":
        ///
        /// <code><![CDATA[
        /// f.AutoFilter("Sheet1", "A1:D4", Array.Empty<AutoFilterOptions>());
        /// ]]></code>
        ///
        /// To filter data within an auto filter:
        ///
        /// <code>
        /// f.AutoFilter("Sheet1", "A1:D4", new AutoFilterOptions[]
        /// {
        ///     new AutoFilterOptions { Column = "B", Expression = "x != blanks" }
        /// });
        /// </code>
        ///
        /// <para>
        /// <b>Column</b> specifies which column in the auto filter range will
        /// apply a filter.
        /// </para>
        ///
        /// <para>
        /// Note: Specifying filter conditions alone is not sufficient. Rows
        /// that do not match the filter criteria must also be hidden manually
        /// using <c>SetRowVisible</c>. The library cannot automatically hide
        /// rows because this is outside the Excel file format's capabilities.
        /// </para>
        ///
        /// <para>
        /// <b>Expression</b> defines the filter criteria. The following
        /// operators are supported:
        /// </para>
        ///
        /// <list type="bullet">
        ///   <item><description><c>==</c></description></item>
        ///   <item><description><c>!=</c></description></item>
        ///   <item><description><c>&gt;</c></description></item>
        ///   <item><description><c>&lt;</c></description></item>
        ///   <item><description><c>&gt;=</c></description></item>
        ///   <item><description><c>&lt;=</c></description></item>
        ///   <item><description><c>and</c></description></item>
        ///   <item><description><c>or</c></description></item>
        /// </list>
        ///
        /// <para>
        /// Expressions may contain a single condition or two conditions
        /// combined using <c>and</c> or <c>or</c>. Examples:
        /// </para>
        ///
        /// <code>
        /// x &lt; 2000
        /// x &gt; 2000
        /// x == 2000
        /// x &gt; 2000 and x &lt; 5000
        /// x == 2000 or x == 5000
        /// </code>
        ///
        /// <para>
        /// Filtering blank or non-blank values:
        /// </para>
        ///
        /// <code>
        /// x == Blanks
        /// x == NonBlanks
        /// </code>
        ///
        /// <para>
        /// Simple string matching is also supported:
        /// </para>
        ///
        /// <code>
        /// x == b*      // begins with b
        /// x != b*      // doesn't begin with b
        /// x == *b      // ends with b
        /// x != *b      // doesn't end with b
        /// x == *b*     // contains b
        /// x != *b*     // doesn't contain b
        /// </code>
        ///
        /// <para>
        /// Wildcards:
        /// </para>
        /// <list type="bullet">
        ///   <item><description><c>*</c> matches any sequence of characters or digits.</description></item>
        ///   <item><description><c>?</c> matches any single character or digit.</description></item>
        ///   <item><description><c>~</c> escapes Excel's wildcard characters.</description></item>
        /// </list>
        ///
        /// <para>
        /// In expressions, the placeholder variable (commonly shown as <c>x</c>)
        /// may be any simple string. The actual placeholder name is ignored, so
        /// the following are equivalent:
        /// </para>
        ///
        /// <code>
        /// x     &lt; 2000
        /// col   &lt; 2000
        /// Price &lt; 2000
        /// </code>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="range">The top-left and right-bottom cell range reference</param>
        /// <param name="opts"> The auto filter options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AutoFilter(string sheet, string range, AutoFilterOptions[] opts)
        {
            TypesC.AutoFilterOptions[] arr = new TypesC.AutoFilterOptions[opts.Length];
            for (int i = 0; i < opts.Length; i++)
            {
                arr[i] = (TypesC.AutoFilterOptions)
                    Lib.CsToC(opts[i], new TypesC.AutoFilterOptions());
            }
            string err = Marshal.PtrToStringUTF8(
                Lib.AutoFilter(FileIdx, sheet, range, arr, arr.Length)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// CalcCellValue provides a function to get calculated cell value. This
        /// feature is currently in working processing. Iterative calculation,
        /// implicit intersection, explicit intersection, array formula, table
        /// formula and some other formulas are not supported currently.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="options">Optional parameters for calculate cell value</param>
        public unsafe string CalcCellValue(string sheet, string cell, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            TypesC.StringErrorResult res = Lib.CalcCellValue(FileIdx, sheet, cell, ref opts);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new(res.val);
        }

        /// <summary>
        /// Closes and cleanup the open temporary file for the spreadsheet.
        /// </summary>
        /// <returns>Returns an error message if the operation fails, otherwise
        /// returns an empty string.</returns>
        public string Close()
        {
            return Marshal.PtrToStringUTF8(Lib.Close(FileIdx));
        }

        /// <summary>
        /// Duplicate a worksheet by gave source and target worksheet index.
        /// Note that currently doesn't support duplicate workbooks that contain
        /// tables, charts or pictures.
        /// </summary>
        /// <param name="from">Source sheet index</param>
        /// <param name="to">Target sheet index</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void CopySheet(int from, int to)
        {
            string err = Marshal.PtrToStringUTF8(Lib.CopySheet(FileIdx, from, to));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Delete chart in spreadsheet by given worksheet name and cell
        /// reference.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void DeleteChart(string sheet, string cell)
        {
            string err = Marshal.PtrToStringUTF8(Lib.DeleteChart(FileIdx, sheet, cell));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Delete comment in a worksheet by given worksheet name and cell
        /// reference.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void DeleteComment(string sheet, string cell)
        {
            string err = Marshal.PtrToStringUTF8(Lib.DeleteComment(FileIdx, sheet, cell));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Delete all pictures in a cell by given worksheet name and cell
        /// reference.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void DeletePicture(string sheet, string cell)
        {
            string err = Marshal.PtrToStringUTF8(Lib.DeletePicture(FileIdx, sheet, cell));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Delete worksheet in a workbook by given worksheet name. Use this
        /// method with caution, which will affect changes in references such as
        /// formulas, charts, and so on. If there is any referenced value of the
        /// deleted worksheet, it will cause a file error when you open it. This
        /// function will be invalid when only one worksheet is left.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void DeleteSheet(string sheet)
        {
            string err = Marshal.PtrToStringUTF8(Lib.DeleteSheet(FileIdx, sheet));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Delete a slicer by a given slicer name.
        /// </summary>
        /// <param name="name">The slicer name</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void DeleteSlicer(string name)
        {
            string err = Marshal.PtrToStringUTF8(Lib.DeleteSlicer(FileIdx, name));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Inserts a copy of specified row (by its Excel row number) below. Use
        /// this method with caution, which will affect changes in references
        /// such as formulas, charts, and so on. If there is any referenced
        /// value of the worksheet, it will cause a file error when you open it.
        /// The excelize only partially updates these references currently.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="row">The row number</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void DuplicateRow(string sheet, int row)
        {
            string err = Marshal.PtrToStringUTF8(Lib.DuplicateRow(FileIdx, sheet, row));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Inserts a copy of specified row by it Excel number to specified row
        /// position moving down exists rows after target position. Use this
        /// method with caution, which will affect changes in references such as
        /// formulas, charts, and so on. If there is any referenced value of the
        /// worksheet, it will cause a file error when you open it. The excelize
        /// only partially updates these references currently.
        /// <example>
        /// For example:
        /// <code>
        /// try
        /// {
        ///     f.DuplicateRowTo("Sheet1", 2, 7);
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="row">The row number to duplicate from</param>
        /// <param name="row2">The row number to duplicate to</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void DuplicateRowTo(string sheet, int row, int row2)
        {
            string err = Marshal.PtrToStringUTF8(Lib.DuplicateRowTo(FileIdx, sheet, row, row2));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Get active sheet index of the spreadsheet. If not found the active
        /// sheet will be return integer 0.
        /// </summary>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public int GetActiveSheetIndex()
        {
            int idx = Lib.GetActiveSheetIndex(FileIdx);
            return idx;
        }

        /// <summary>
        /// Get document application properties.
        /// </summary>
        /// <returns>Return the application properties if no error occurred,
        /// otherwise raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe AppProperties GetAppProps()
        {
            TypesC.GetAppPropsResult res = Lib.GetAppProps(FileIdx);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return (AppProperties)Lib.CToCs(res.opts, new AppProperties());
        }

        /// <summary>
        /// Gets calculation properties.
        /// </summary>
        /// <returns>Return the calculation properties if no error occurred,
        /// otherwise raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe CalcPropsOptions GetCalcProps()
        {
            TypesC.GetCalcPropsResult res = Lib.GetCalcProps(FileIdx);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return (CalcPropsOptions)Lib.CToCs(res.opts, new CalcPropsOptions());
        }

        /// <summary>
        /// GetCellFormula provides a function to get formula from cell by given
        /// worksheet name and cell reference in spreadsheet.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <returns>Return the cell value if no error occurred, otherwise raise
        /// a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe string GetCellFormula(string sheet, string cell)
        {
            TypesC.StringErrorResult res = Lib.GetCellFormula(FileIdx, sheet, cell);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new(res.val);
        }

        /// <summary>
        /// Get formatted value from cell by given worksheet name and cell
        /// reference in spreadsheet. The return value is converted to the
        /// <c>string</c> data type. If the cell format can be applied to the
        /// value of a cell, the applied value will be returned, otherwise the
        /// original value will be returned. All cells' values will be the same
        /// in a merged range.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="options">Optional parameters for get cell value</param>
        /// <returns>Return the cell value if no error occurred, otherwise raise
        /// a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe string GetCellValue(string sheet, string cell, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            TypesC.StringErrorResult res = Lib.GetCellValue(FileIdx, sheet, cell, ref opts);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new(res.val);
        }

        /// <summary>
        /// Return all the rows in a sheet by given worksheet name, returned as
        /// a two-dimensional array, where the value of the cell is converted to
        /// the string type. If the cell format can be applied to the value of
        /// the cell, the applied value will be used, otherwise the original
        /// value will be used. This function fetched the rows with value or
        /// formula cells, the continually blank cells in the tail of each row
        /// will be skipped, so the length of each row may be inconsistent.
        /// <example>
        /// For example, get and traverse the value of all cells by rows on a
        /// worksheet named 'Sheet1':
        /// <code>
        /// var rows = f.GetRows("Sheet1");
        /// foreach (var row in rows)
        /// {
        ///     foreach (var cell in row)
        ///     {
        ///         Console.Write($"{cell}\t");
        ///     }
        ///     Console.WriteLine();
        /// }
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">Optional parameters for get rows</param>
        /// <returns>Return all the rows in a sheet by given worksheet name,
        /// returned as a two-dimensional array if no error occurred, otherwise
        /// raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe List<List<string>> GetRows(string sheet, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            TypesC.StringMatrixErrorResult res = Lib.GetRows(FileIdx, sheet, ref opts);
            var rows = new List<List<string>>();
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            var result = (StringMatrixErrorResult)Lib.CToCs(res, new StringMatrixErrorResult());
            foreach (var r in result.Row)
            {
                var row = new List<string>();
                if (r.Cell != null)
                {
                    foreach (var c in r.Cell)
                    {
                        row.Add(c);
                    }
                }
                rows.Add(row);
            }
            return rows;
        }

        /// <summary>
        /// Get style definition by given style ID.
        /// </summary>
        /// <param name="styleId">The style ID</param>
        /// <returns>Return the style definition if no error occurred, otherwise
        /// raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe Style GetStyle(long styleId)
        {
            TypesC.GetStyleResult res = Lib.GetStyle(FileIdx, styleId);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            var style = (Style)Lib.CToCs(res.style, new Style());
            return style;
        }

        /// <summary>
        /// Create a new sheet by given a worksheet name and returns the index
        /// of the sheets in the workbook after it appended. Note that when
        /// creating a new workbook, the default worksheet named <c>Sheet1</c>
        /// will be created.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <returns>Return the index of the sheets in the workbook if no error
        /// occurred, otherwise raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe int NewSheet(string sheet)
        {
            var res = Lib.NewSheet(FileIdx, sheet);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return res.val;
        }

        /// <summary>
        /// Returns stream writer struct by given worksheet name used for
        /// writing data on a new existing empty worksheet with large amounts of
        /// data. Note that after writing data with the stream writer for the
        /// worksheet, you must call the 'flush' method to end the streaming
        /// writing process, ensure that the order of row numbers is ascending
        /// when set rows, and the normal mode functions and stream mode
        /// functions can not be work mixed to writing data on the worksheets.
        /// The stream writer will try to use temporary files on disk to reduce
        /// the memory usage when in-memory chunks data over 16MB, and you can't
        /// get cell value at this time.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <returns>Return the stream writer object if no error occurred,
        /// otherwise raise a RuntimeError with the message.
        /// </returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe StreamWriter NewStreamWriter(string sheet)
        {
            var res = Lib.NewStreamWriter(FileIdx, sheet);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new StreamWriter { StreamWriterIdx = res.val };
        }

        /// <summary>
        /// Create the style for cells by a given style options, and returns
        /// style index. The same style index can not be used across different
        /// workbook. Note that the 'font.color' field uses an RGB color
        /// represented in 'RRGGBB' hexadecimal notation.
        /// </summary>
        /// <param name="style">The style options</param>
        /// <returns>Return the style index if no error occurred, otherwise
        /// raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe int NewStyle(Style style)
        {
            var options = (TypesC.Style)Lib.CsToC(style, new TypesC.Style());
            var res = Lib.NewStyle(FileIdx, ref options);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return res.val;
        }

        /// <summary>
        /// Override the spreadsheet with origin path.
        /// </summary>
        /// <param name="options">Optional parameters for saving the file</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void Save(Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            string err = Marshal.PtrToStringUTF8(Lib.Save(FileIdx, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Create or update to a spreadsheet at the provided path.
        /// </summary>
        /// <param name="filename">The name of the file to save</param>
        /// <param name="options">Optional parameters for saving the file</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SaveAs(string filename, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            string err = Marshal.PtrToStringUTF8(Lib.SaveAs(FileIdx, filename, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set the default active sheet of the workbook by a given index.
        /// </summary>
        /// <remarks>Note that the active index is different from the ID
        /// returned by function <c>GetSheetMap</c>. It should be greater than
        /// or equal to 0 and less than the total worksheet numbers.</remarks>
        /// <param name="index">The index of the worksheet to be set as active.
        /// </param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetActiveSheet(int index)
        {
            string err = Marshal.PtrToStringUTF8(Lib.SetActiveSheet(FileIdx, index));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set document application properties. The properties that can be set are:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Property</term>
        ///     <description>Description</description>
        ///   </listheader>
        ///   <item>
        ///     <term>Application</term>
        ///     <description>
        ///       The name of the application that created this document.
        ///     </description>
        ///   </item>
        ///   <item>
        ///     <term>ScaleCrop</term>
        ///     <description>
        ///       Indicates the display mode of the document thumbnail.
        ///       Set to <c>true</c> to enable scaling of the document thumbnail to the display.
        ///       Set to <c>false</c> to enable cropping of the document thumbnail to show only
        ///       sections that will fit the display.
        ///     </description>
        ///   </item>
        ///   <item>
        ///     <term>DocSecurity</term>
        ///     <description>
        ///       Security level of the document as a numeric value:
        ///       <list type="number">
        ///         <item><description>Document is password protected.</description></item>
        ///         <item><description>Document is recommended to be opened as read-only.</description></item>
        ///         <item><description>Document is enforced to be opened as read-only.</description></item>
        ///         <item><description>Document is locked for annotation.</description></item>
        ///       </list>
        ///     </description>
        ///   </item>
        ///   <item>
        ///     <term>Company</term>
        ///     <description>
        ///       The name of a company associated with the document.
        ///     </description>
        ///   </item>
        ///   <item>
        ///     <term>LinksUpToDate</term>
        ///     <description>
        ///       Indicates whether hyperlinks in the document are up to date.
        ///       Set to <c>true</c> if hyperlinks are updated; otherwise, <c>false</c>.
        ///     </description>
        ///   </item>
        ///   <item>
        ///     <term>HyperlinksChanged</term>
        ///     <description>
        ///       Specifies that one or more hyperlinks in this part were updated exclusively
        ///       by a producer. The next producer to open this document shall update the
        ///       hyperlink relationships with the new hyperlinks specified in this part.
        ///     </description>
        ///   </item>
        ///   <item>
        ///     <term>AppVersion</term>
        ///     <description>
        ///       Specifies the version of the application that produced this document.
        ///       The value must be in the form <c>XX.YYYY</c>, where X and Y represent numerical
        ///       values; otherwise, the document is considered non-conformant.
        ///     </description>
        ///   </item>
        /// </list>
        /// <example>
        /// For example:
        /// <code>
        /// try
        /// {
        ///     f.SetAppProps(
        ///         new AppProperties
        ///         {
        ///             Application = "Microsoft Excel",
        ///             ScaleCrop = true,
        ///             DocSecurity = 3,
        ///             Company = "Company Name",
        ///             LinksUpToDate = true,
        ///             HyperlinksChanged = true,
        ///             AppVersion = "16.0000",
        ///         }
        ///     );
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="appProperties">The application properties</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetAppProps(AppProperties appProperties)
        {
            var opts = (TypesC.AppProperties)Lib.CsToC(appProperties, new TypesC.AppProperties());
            string err = Marshal.PtrToStringUTF8(Lib.SetAppProps(FileIdx, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Sets calculation properties. Optional value of <c>CalcMode</c>
        /// property is: <c>manual</c>, <c>auto</c> or <c>autoNoTable</c>.
        /// Optional value of <c>RefMode</c> property is: <c>A1</c> or
        /// <c>R1C1</c>.
        /// </summary>
        /// <param name="opts">The calculation properties</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCalcProps(CalcPropsOptions opts)
        {
            var options = (TypesC.CalcPropsOptions)Lib.CsToC(opts, new TypesC.CalcPropsOptions());
            string err = Marshal.PtrToStringUTF8(Lib.SetCalcProps(FileIdx, ref options));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set bool type value of a cell by given worksheet name, cell
        /// reference and cell value.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="value">The cell value</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCellBool(string sheet, string cell, bool value)
        {
            string err = Marshal.PtrToStringUTF8(Lib.SetCellBool(FileIdx, sheet, cell, value));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set string type value of a cell as default format without escaping
        /// the cell.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="value">The cell value</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCellDefault(string sheet, string cell, string value)
        {
            string err = Marshal.PtrToStringUTF8(Lib.SetCellDefault(FileIdx, sheet, cell, value));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// SetCellFormula provides a function to set formula on the cell is
        /// taken according to the given worksheet name and cell formula
        /// settings. The result of the formula cell can be calculated when the
        /// worksheet is opened by the Office Excel application or can be using
        /// the "CalcCellValue" function also can get the calculated cell
        /// value. If the Excel application doesn't calculate the formula
        /// automatically when the workbook has been opened, please call
        /// <c>UpdateLinkedValue</c> after setting the cell formula functions.
        /// <example>
        /// Example 1, set normal formula <c>SUM(A1,B1)</c> for the cell
        /// <c>A3</c> on <c>Sheet1</c>:
        /// <code>
        /// try
        /// {
        ///     f.SetCellFormula("Sheet1", "A3", "SUM(A1,B1)");
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// Example 2, set one-dimensional vertical constant array (column
        /// array) formula <c>1,2,3</c> for the cell <c>A3</c> on <c>Sheet1</c>:
        /// <code>
        /// try
        /// {
        ///     f.SetCellFormula("Sheet1", "A3", "{1;2;3}");
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// Example 3, set one-dimensional horizontal constant array (row array)
        /// formula <c>"a","b","c"</c> for the cell <c>A3</c> on <c>Sheet1</c>:
        /// <code>
        /// try
        /// {
        ///     f.SetCellFormula("Sheet1", "A3", "{\"a\",\"b\",\"c\"}");
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// Example 4, set two-dimensional constant array formula
        /// <c>{1,2,"a","b"}</c> for the cell <c>A3</c> on <c>Sheet1</c>:
        /// <code>
        /// try
        /// {
        ///     f.SetCellFormula(
        ///         "Sheet1",
        ///         "A3",
        ///         "{1,2;\"a\",\"b\"}",
        ///         new FormulaOpts
        ///         {
        ///             Ref = "A3:A3",
        ///             Type = Excelize.STCellFormulaTypeArray,
        ///         }
        ///     );
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// Example 5, set range array formula <c>A1:A2</c> for the cell
        /// <c>A3</c> on <c>Sheet1</c>:
        /// <code>
        /// try
        /// {
        ///     f.SetCellFormula(
        ///         "Sheet1",
        ///         "A3",
        ///         "A1:A2",
        ///         new FormulaOpts
        ///         {
        ///             Ref = "A3:A3",
        ///             Type = Excelize.STCellFormulaTypeArray,
        ///         }
        ///     );
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// Example 6, set shared formula <c>A1+B1</c> for the cell <c>C1:C5</c>
        /// on <c>Sheet1</c>, <c>C1</c> is the master cell:
        /// <code>
        /// try
        /// {
        ///     f.SetCellFormula(
        ///         "Sheet1",
        ///         "C1",
        ///         "A1+B1",
        ///         new FormulaOpts
        ///         {
        ///             Ref = "C1:C5",
        ///             Type = Excelize.STCellFormulaTypeShared,
        ///         }
        ///     );
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// Example 7, set table formula <c>SUM(Table1[[A]:[B]])</c> for the
        /// cell <c>C2</c> on <c>Sheet1</c>:
        /// <code><![CDATA[
        /// using ExcelizeCs;
        ///
        /// class Program
        /// {
        ///     static void Main()
        ///     {
        ///         ExcelizeCs.File f = Excelize.NewFile();
        ///         try
        ///         {
        ///             f.SetSheetRow("Sheet1", "A1", new List<object> { "A", "B", "C" });
        ///             f.SetSheetRow("Sheet1", "A2", new List<object> { 1, 2 });
        ///             f.AddTable(
        ///                 "Sheet1",
        ///                 new Table
        ///                 {
        ///                     Range = "A1:C2",
        ///                     Name = "Table1",
        ///                     StyleName = "TableStyleMedium2",
        ///                 }
        ///             );
        ///             f.SetCellFormula(
        ///                 "Sheet1",
        ///                 "C2",
        ///                 "SUM(Table1[[A]:[B]])",
        ///                 new FormulaOpts { Type = Excelize.STCellFormulaTypeDataTable }
        ///             );
        ///             f.SaveAs("Book1.xlsx");
        ///         }
        ///         catch (RuntimeError err)
        ///         {
        ///             Console.WriteLine(err.Message);
        ///         }
        ///         finally
        ///         {
        ///             string err = f.Close();
        ///             if (!string.IsNullOrEmpty(err))
        ///                 Console.WriteLine(err);
        ///         }
        ///     }
        /// }]]>
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="formula">The cell formula</param>
        /// <param name="options">Optional parameters for set cell formula</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCellFormula(
            string sheet,
            string cell,
            string formula,
            FormulaOpts? options = null
        )
        {
            var opts = (TypesC.FormulaOpts)
                Lib.CsToC(options ?? new FormulaOpts(), new TypesC.FormulaOpts());
            string err = Marshal.PtrToStringUTF8(
                Lib.SetCellFormula(FileIdx, sheet, cell, formula, ref opts)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set int type value of a cell by given worksheet name, cell reference
        /// and cell value.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="value">The cell value</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCellInt(string sheet, string cell, long value)
        {
            string err = Marshal.PtrToStringUTF8(Lib.SetCellInt(FileIdx, sheet, cell, value));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set int type value of a cell by given worksheet name, cell reference
        /// and cell value.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="topLeftCell">The cell reference</param>
        /// <param name="bottomRightCell">The cell value</param>
        /// <param name="styleID">The cell value</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCellStyle(
            string sheet,
            string topLeftCell,
            string bottomRightCell,
            long styleID
        )
        {
            string err = Marshal.PtrToStringUTF8(
                Lib.SetCellStyle(FileIdx, sheet, topLeftCell, bottomRightCell, styleID)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set value of a cell by given worksheet name, cell reference and cell
        /// value.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="value">The cell value</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCellValue(string sheet, string cell, object value)
        {
            var val = (TypesC.Interface)Lib.CsValToCInterface(value);
            string err = Marshal.PtrToStringUTF8(Lib.SetCellValue(FileIdx, sheet, cell, ref val));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// SetSheetProps provides a function to set worksheet properties.
        /// <example>
        /// There 4 kinds of presets "Custom Scaling Options" in the spreadsheet
        /// applications, if you need to set those kind of scaling options,
        /// please using the <c>SetSheetProps</c> and <c>SetPageLayout</c>
        /// functions to approach these 4 scaling options:
        /// 1. No Scaling (Print sheets at their actual size):
        /// <code>
        /// try
        /// {
        ///     f.SetSheetProps("Sheet1", new SheetPropsOptions { FitToPage = false });
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// 2. Fit Sheet on One Page (Shrink the printout so that it fits on one
        /// page):
        /// <code>
        /// try
        /// {
        ///     f.SetSheetProps("Sheet1", new SheetPropsOptions { FitToPage = true });
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// 3. Fit All Columns on One Page (Shrink the printout so that it is
        /// one page wide):
        /// <code>
        /// try
        /// {
        ///     f.SetSheetProps("Sheet1", new SheetPropsOptions { FitToPage = true });
        ///     f.SetPageLayout("Sheet1", new PageLayoutOptions { FitToHeight = 0 });
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// 4. Fit All Rows on One Page (Shrink the printout so that it is one
        /// page high):
        /// <code>
        /// try
        /// {
        ///     f.SetSheetProps("Sheet1", new SheetPropsOptions { FitToPage = true });
        ///     f.SetPageLayout("Sheet1", new PageLayoutOptions { FitToWidth = 0 });
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The sheet properties options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetSheetProps(string sheet, SheetPropsOptions options)
        {
            var opts = (TypesC.SheetPropsOptions)Lib.CsToC(options, new TypesC.SheetPropsOptions());
            string err = Marshal.PtrToStringUTF8(Lib.SetSheetProps(FileIdx, sheet, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set headers and footers by given worksheet name and the control
        /// characters.
        /// <example>
        /// For example:
        /// <code><![CDATA[
        /// try
        /// {
        ///     f.SetHeaderFooter(
        ///         "Sheet1",
        ///         new HeaderFooterOptions
        ///         {
        ///             DifferentFirst = true,
        ///             DifferentOddEven = true,
        ///             OddHeader = "&R&P",
        ///             OddFooter = "&C&F",
        ///             EvenHeader = "&L&P",
        ///             EvenFooter = "&L&D&R&T",
        ///             FirstHeader = "&CCenter &\"-,Bold\"Bold&\"-,Regular\"HeaderU+000A&D",
        ///         }
        ///     );
        /// }
        /// catch (RuntimeError err)
        /// {
        ///     Console.WriteLine(err.Message);
        /// }]]>
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The header footer options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetHeaderFooter(string sheet, HeaderFooterOptions? options)
        {
            var opts = (TypesC.HeaderFooterOptions)
                Lib.CsToC(options ?? new HeaderFooterOptions(), new TypesC.HeaderFooterOptions());
            string err = Marshal.PtrToStringUTF8(Lib.SetHeaderFooter(FileIdx, sheet, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Writes cells to row by given worksheet name, starting cell reference
        /// and cell values list.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="values">The cell values</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetSheetRow(string sheet, string cell, List<object> values)
        {
            if (values == null || values.Count == 0)
                return;
            var arr = new TypesC.Interface[values.Count];
            for (int i = 0; i < values.Count; i++)
            {
                arr[i] = (TypesC.Interface)Lib.CsValToCInterface(values[i]);
            }
            string err = Marshal.PtrToStringUTF8(
                Lib.SetSheetRow(FileIdx, sheet, cell, arr, values.Count)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Fix linked values within a spreadsheet are not updating in Office
        /// Excel application. This function will be remove value tag when met a
        /// cell have a linked value.
        /// </summary>
        /// <remarks>After opening generated workbook, Excel will update the
        /// linked value and generate a new value and will prompt to save the
        /// file or not.</remarks>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void UpdateLinkedValue()
        {
            string err = Marshal.PtrToStringUTF8(Lib.UpdateLinkedValue(FileIdx));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }
    }

    /// <summary>
    /// RuntimeError is raised when an error occurs during the execution of a
    /// function in the Excelize library.
    /// </summary>
    /// <remarks>The RuntimeError class extends the built-in Exception class
    /// and provides a way to represent errors specific to the Excelize
    /// library.</remarks>
    public class RuntimeError : Exception
    {
        /// <summary>
        /// Initializes a new instance of the RuntimeError class.
        /// </summary>
        /// <param name="message">The error message.</param>
        public RuntimeError(string message)
            : base(message) { }
    }
}
