// Copyright 2025 The excelize Authors. All rights reserved. Use of this source
// code is governed by a BSD-style license that can be found in the LICENSE
// file.
//
// Package excelize-cs is a C# port of Go Excelize library, providing a set of
// functions that allow you to write and read from XLAM / XLSM / XLSX / XLTM /
// XLTX files. Supports reading and writing spreadsheet documents generated by
// Microsoft Excelâ„¢ 2007 and later. Supports complex components by high
// compatibility, and provided streaming API for generating or reading data from
// a worksheet with huge amounts of data. This library needs .NET version 6, C#
// version 10 or later.

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;

namespace ExcelizeCs
{
    public static class Lib
    {
        private const string LibraryName = "libexcelize";
        public const string ErrUnsupportedPlatformOrArch =
            "This platform or architecture is not supported.";

        static Lib()
        {
            NativeLibrary.SetDllImportResolver(Assembly.GetExecutingAssembly(), DllImportResolver);
        }

        public static IntPtr DllImportResolver(
            string libraryName,
            Assembly assembly,
            DllImportSearchPath? searchPath
        )
        {
            var extMap = new Dictionary<string, string>
            {
                { "linux", ".so" },
                { "darwin", ".dylib" },
                { "windows", ".dll" },
            };
            var osList = new List<(bool, List<string>)>
            {
                (
                    RuntimeInformation.IsOSPlatform(OSPlatform.Windows),
                    new List<string> { "windows", ".dll" }
                ),
                (
                    RuntimeInformation.IsOSPlatform(OSPlatform.Linux),
                    new List<string> { "linux", ".so" }
                ),
                (
                    RuntimeInformation.IsOSPlatform(OSPlatform.OSX),
                    new List<string> { "darwin", ".dylib" }
                ),
            };
            var archMap = new Dictionary<Architecture, string>
            {
                { Architecture.X64, "amd64" },
                { Architecture.X86, "386" },
                { Architecture.Arm64, "arm64" },
            };
            string ext = "";
            string system = "";
            var os = osList.Find(os => os.Item1);
            if (os.Item1)
            {
                system = os.Item2[0];
                ext = os.Item2[1];
            }
            string lib = Path.Combine(
                AppDomain.CurrentDomain.BaseDirectory,
                $"{libraryName}.{archMap[RuntimeInformation.ProcessArchitecture]}.{system}{ext}"
            );
            if (NativeLibrary.TryLoad(lib, out IntPtr handle))
            {
                return handle;
            }
            throw new RuntimeError(ErrUnsupportedPlatformOrArch);
        }

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr AddChart(
            long fileIdx,
            string sheet,
            string cell,
            [In, MarshalAs(UnmanagedType.LPArray)] TypesC.Chart[] chart,
            int length
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr AddChartSheet(
            long fileIdx,
            string sheet,
            [In, MarshalAs(UnmanagedType.LPArray)] TypesC.Chart[] chart,
            int length
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr AddComment(
            long fileIdx,
            string sheet,
            ref TypesC.Comment comment
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr AddPicture(
            long fileIdx,
            string sheet,
            string cell,
            string name,
            ref TypesC.GraphicOptions opts
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr AddVBAProject(long fileIdx, byte[] b, int bLen);

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.CellNameToCoordinatesResult CellNameToCoordinates(
            string cell
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr Close(long fileIdx);

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.IntErrorResult ColumnNameToNumber(string name);

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.StringErrorResult ColumnNumberToName(int num);

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.StringErrorResult CoordinatesToCellName(
            int col,
            int row,
            bool abs
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.StringErrorResult GetCellValue(
            long fileIdx,
            string sheet,
            string cell,
            ref TypesC.Options opts
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.GetRowsResult GetRows(
            long fileIdx,
            string sheet,
            ref TypesC.Options opts
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.GetStyleResult GetStyle(long fileIdx, long styleID);

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern long NewFile();

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.IntErrorResult NewSheet(long fileIdx, string sheet);

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.IntErrorResult NewStyle(long fileIdx, ref TypesC.Style style);

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.IntErrorResult OpenFile(
            string filename,
            ref TypesC.Options options
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern TypesC.IntErrorResult OpenReader(
            byte[] b,
            int bLen,
            ref TypesC.Options options
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr Save(long fileIdx, ref TypesC.Options options);

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr SaveAs(
            long fileIdx,
            string filename,
            ref TypesC.Options options
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr SetActiveSheet(long fileIdx, int index);

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr SetCellInt(
            long fileIdx,
            string sheet,
            string cell,
            long value
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr SetCellStyle(
            long fileIdx,
            string sheet,
            string topLeftCell,
            string bottomRightCell,
            long styleID
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr SetCellValue(
            long fileIdx,
            string sheet,
            string cell,
            ref TypesC.Interface value
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr SetSheetRow(
            long fileIdx,
            string sheet,
            string cell,
            [In, MarshalAs(UnmanagedType.LPArray)] TypesC.Interface[] row,
            int length
        );

        [DllImport(
            LibraryName,
            CallingConvention = CallingConvention.Cdecl,
            CharSet = CharSet.Ansi
        )]
        internal static extern IntPtr UpdateLinkedValue(long fileIdx);

        /// <summary>
        /// Checks if is a nullable object reference type, for example: Class?.
        /// </summary>
        /// <param name="field"></param>
        /// <returns></returns>
        internal static bool IsNullableRefType(FieldInfo field)
        {
            var n = new NullabilityInfoContext().Create(field);
            return n.ReadState == NullabilityState.Nullable;
        }

        /// <summary>
        /// Checks if is a Go primitive type, for example: int, string, bool.
        /// </summary>
        /// <param name="type">Type to check</param>
        /// <returns>return true if the type is a Go primitive type, otherwise
        /// false</returns>
        internal static bool IsGoPrimitiveType(Type type)
        {
            return type.IsPrimitive
                || type.IsEnum
                || type == typeof(string)
                || type == typeof(decimal);
        }

        /// <summary>
        /// Marshal a C# value to a C Interface struct.
        /// </summary>
        /// <param name="value">The value to marshal</param>
        /// <returns>The marshaled C Interface struct</returns>
        public static object CsValToCInterface(object value)
        {
            return CsToC(
                value switch
                {
                    int _ => new Interface { Type = 1, Integer = (int)value },
                    string _ => new Interface { Type = 2, String = (string)value },
                    double _ => new Interface { Type = 3, Float = (double)value },
                    float _ => new Interface { Type = 3, Float = (float)value },
                    long _ => new Interface { Type = 3, Float = (long)value },
                    short _ => new Interface { Type = 3, Float = (short)value },
                    bool _ => new Interface { Type = 4, Boolean = (bool)value },
                    _ => new Interface { Type = 0 },
                },
                new TypesC.Interface()
            );
        }

        /// <summary>
        /// Marshal a C# primitive value to an pointer.
        /// </summary>
        /// <param name="value">The value to marshal</param>
        /// <returns>Pointer to the marshaled value</returns>
        private static IntPtr MarshalPrimitiveValue(object value)
        {
            Type valueType = value.GetType();
            IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(valueType));
            switch (Type.GetTypeCode(valueType))
            {
                case TypeCode.Boolean:
                    Marshal.WriteByte(ptr, Convert.ToByte(value));
                    break;
                case TypeCode.Byte:
                    Marshal.WriteByte(ptr, (byte)value);
                    break;
                case TypeCode.Int16:
                case TypeCode.UInt16:
                    Marshal.WriteInt16(ptr, Convert.ToInt16(value));
                    break;
                case TypeCode.Int32:
                case TypeCode.UInt32:
                    Marshal.WriteInt32(ptr, Convert.ToInt32(value));
                    break;
                case TypeCode.Int64:
                case TypeCode.UInt64:
                    Marshal.WriteInt64(ptr, Convert.ToInt64(value));
                    break;
                case TypeCode.Single:
                case TypeCode.Double:
                    byte[] bytes =
                        valueType == typeof(float)
                            ? BitConverter.GetBytes((float)value)
                            : BitConverter.GetBytes((double)value);
                    Marshal.Copy(bytes, 0, ptr, bytes.Length);
                    break;
            }
            return ptr;
        }

        /// <summary>
        /// Unmarshal a pointer to a C primitive value to a C# primitive value.
        /// </summary>
        /// <param name="ptr">Pointer to the C primitive value</param>
        /// <param name="targetType">The target C# type</param>
        /// <returns>The unmarshaled C# primitive value</returns>
        /// <exception cref="NotSupportedException">Thrown if the target type is
        /// not supported</exception>
        /// <remarks>
        /// This function handles various primitive types including int, bool,
        /// double, float, long, short, byte, sbyte, uint, ulong, ushort, and
        /// string. If the pointer is null, it returns null.
        /// </remarks>
        public static object UnmarshalPrimitiveValue(IntPtr ptr, Type targetType)
        {
            if (ptr == IntPtr.Zero)
                return null;
            Type underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;
            return underlyingType switch
            {
                Type t when t == typeof(int) => Marshal.ReadInt32(ptr),
                Type t when t == typeof(bool) => Marshal.ReadByte(ptr) != 0,
                Type t when t == typeof(double) => Marshal.PtrToStructure<double>(ptr),
                Type t when t == typeof(float) => Marshal.PtrToStructure<float>(ptr),
                Type t when t == typeof(long) => Marshal.ReadInt64(ptr),
                Type t when t == typeof(short) => Marshal.ReadInt16(ptr),
                Type t when t == typeof(byte) => Marshal.ReadByte(ptr),
                Type t when t == typeof(uint) => (uint)Marshal.ReadInt32(ptr),
                Type t when t == typeof(ulong) => (ulong)Marshal.ReadInt64(ptr),
                Type t when t == typeof(ushort) => (ushort)Marshal.ReadInt16(ptr),
                _ => null,
            };
        }

        /// <summary>
        /// Convert a C instance to a C# instance by mapping fields to the
        /// corresponding fields in the C# instance.
        /// </summary>
        /// <param name="cInstance">The C-compatible struct instance to be
        /// converted.</param>
        /// <param name="csInstance">The C# instance to which the converted
        /// values will be assigned</param>
        /// <returns>The populated C# instance</returns>
        public static unsafe object CToCs(object cInstance, object csInstance)
        {
            if (cInstance == null)
                return null;

            foreach (
                var csField in csInstance
                    .GetType()
                    .GetFields(BindingFlags.Public | BindingFlags.Instance)
            )
            {
                var csFieldName = csField.Name;
                var cFieldName = csFieldName;
                var cField = cInstance.GetType().GetField(cFieldName);
                if (!IsNullableRefType(csField))
                {
                    if (IsGoPrimitiveType(csField.FieldType))
                    {
                        if (csField.FieldType == typeof(string))
                        {
                            var cVal = cField.GetValue(cInstance);
                            sbyte* ptr = (sbyte*)Pointer.Unbox(cVal);
                            string str = new(ptr);
                            if (!string.IsNullOrEmpty(str))
                            {
                                csField.SetValue(csInstance, str);
                            }
                        }
                        else
                        {
                            csField.SetValue(csInstance, cField.GetValue(cInstance));
                        }
                        continue;
                    }
                    else
                    {
                        // The Go struct, for example: excelize.Options, convert sub fields recursively
                        csField.SetValue(
                            csInstance,
                            CToCs(
                                cField.GetValue(cInstance),
                                Activator.CreateInstance(csField.FieldType)
                            )
                        );
                    }
                }
                else
                {
                    if (!csField.FieldType.IsArray)
                    {
                        // Pointer of the Go data type, for example: *excelize.Options or *string
                        if (cField != null)
                        {
                            if (
                                csField.FieldType == typeof(string)
                                || IsGoPrimitiveType(Nullable.GetUnderlyingType(csField.FieldType))
                            )
                            {
                                // Pointer of the Go basic data type, for example: *string
                                var cVal = cField.GetValue(cInstance);
                                if (csField.FieldType == typeof(string))
                                {
                                    sbyte** ptrPtr = (sbyte**)Pointer.Unbox(cVal);
                                    sbyte* ptr = *ptrPtr;
                                    string str = new(ptr);
                                    csField.SetValue(csInstance, str);
                                }
                                else
                                {
                                    csField.SetValue(
                                        csInstance,
                                        UnmarshalPrimitiveValue(
                                            (IntPtr)Pointer.Unbox(cVal),
                                            csField.FieldType
                                        )
                                    );
                                }
                            }
                            else
                            {
                                // Pointer of the Go struct, for example: *excelize.Options
                                var cVal = cField.GetValue(cInstance);
                                var csType = Nullable.GetUnderlyingType(csField.FieldType);
                                if (cVal != null)
                                {
                                    IntPtr ptr = (IntPtr)Pointer.Unbox(cVal);
                                    if (ptr != IntPtr.Zero)
                                    {
                                        Type cStructType = Type.GetType(
                                            $"ExcelizeCs.TypesC.{csType.Name}"
                                        );
                                        object cStructInstance = Marshal.PtrToStructure(
                                            ptr,
                                            cStructType
                                        );
                                        csField.SetValue(
                                            csInstance,
                                            CToCs(cStructInstance, Activator.CreateInstance(csType))
                                        );
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // The Go data type array, for example:
                        // []*excelize.Options, []excelize.Options, []string, []*string
                        var n = new NullabilityInfoContext().Create(csField);
                        if (n.ElementType.ReadState == NullabilityState.NotNull)
                        {
                            // The Go data type array, for example: []excelize.Options or []string
                            var cVal = cField.GetValue(cInstance);
                            var l = Convert.ToInt32(
                                cInstance.GetType().GetField(cFieldName + "Len").GetValue(cInstance)
                            );
                            Array arr = Array.CreateInstance(csField.FieldType.GetElementType(), l);
                            if (l > 0)
                            {
                                if (IsGoPrimitiveType(csField.FieldType.GetElementType()))
                                {
                                    // The Go basic data type array, for example: []string
                                    if (csField.FieldType.GetElementType() == typeof(string))
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr strPtr = Marshal.ReadIntPtr(
                                                arrPtr,
                                                i * IntPtr.Size
                                            );
                                            arr.SetValue(Marshal.PtrToStringAnsi(strPtr), i);
                                        }
                                    }
                                    else
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr elePtr = IntPtr.Add(
                                                arrPtr,
                                                i * Marshal.SizeOf(typeof(int))
                                            );
                                            var val = UnmarshalPrimitiveValue(
                                                elePtr,
                                                csField.FieldType.GetElementType()
                                            );
                                            arr.SetValue(val, i);
                                        }
                                    }
                                }
                                else
                                {
                                    // The Go struct array, for example: []excelize.Options
                                    var csEleType = csField.FieldType.GetElementType();
                                    if (csEleType != null)
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        int structSize = Marshal.SizeOf(
                                            Type.GetType($"ExcelizeCs.TypesC.{csEleType.Name}")
                                        );
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr elePtr = IntPtr.Add(arrPtr, i * structSize);
                                            var cEle = Marshal.PtrToStructure(
                                                elePtr,
                                                Type.GetType($"ExcelizeCs.TypesC.{csEleType.Name}")
                                            );
                                            arr.SetValue(
                                                CToCs(cEle, Activator.CreateInstance(csEleType)),
                                                i
                                            );
                                        }
                                    }
                                }
                                csField.SetValue(csInstance, arr);
                            }
                        }
                        else
                        {
                            // Pointer array of the Go data type, for example:
                            // []*excelize.Options or []*string
                            var cVal = cField.GetValue(cInstance);
                            var l = Convert.ToInt32(
                                cInstance.GetType().GetField(cFieldName + "Len").GetValue(cInstance)
                            );
                            Type eleType = csField.FieldType.GetElementType();
                            Type underlyingType = Nullable.GetUnderlyingType(eleType) ?? eleType;
                            if (l > 0)
                            {
                                if (IsGoPrimitiveType(underlyingType))
                                {
                                    // Pointer array of the Go basic data type, for example: []*string
                                    Array arr = Array.CreateInstance(eleType, l);
                                    if (l > 0)
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr ptrToElement = Marshal.ReadIntPtr(
                                                arrPtr,
                                                i * IntPtr.Size
                                            );
                                            if (ptrToElement != IntPtr.Zero)
                                            {
                                                if (underlyingType == typeof(string))
                                                {
                                                    string strValue = Marshal.PtrToStringAnsi(
                                                        ptrToElement
                                                    );
                                                    arr.SetValue(strValue, i);
                                                }
                                                else
                                                {
                                                    object value = UnmarshalPrimitiveValue(
                                                        ptrToElement,
                                                        underlyingType
                                                    );
                                                    arr.SetValue(value, i);
                                                }
                                            }
                                            else
                                            {
                                                arr.SetValue(null, i);
                                            }
                                        }
                                    }
                                    csField.SetValue(csInstance, arr);
                                }
                                else
                                {
                                    // Pointer array of the Go struct, for example: []*excelize.Options
                                    Array arr = Array.CreateInstance(eleType, l);
                                    if (l > 0)
                                    {
                                        IntPtr arrPtr = (IntPtr)Pointer.Unbox(cVal);
                                        for (int i = 0; i < l; i++)
                                        {
                                            IntPtr ptrToStruct = Marshal.ReadIntPtr(
                                                arrPtr,
                                                i * IntPtr.Size
                                            );
                                            if (ptrToStruct != IntPtr.Zero)
                                            {
                                                Type cStructType = Type.GetType(
                                                    $"ExcelizeCs.TypesC.{underlyingType.Name}"
                                                );
                                                object cStructInstance = Marshal.PtrToStructure(
                                                    ptrToStruct,
                                                    cStructType
                                                );
                                                object csStructInstance = Activator.CreateInstance(
                                                    underlyingType
                                                );
                                                object convertedStruct = CToCs(
                                                    cStructInstance,
                                                    csStructInstance
                                                );
                                                arr.SetValue(convertedStruct, i);
                                            }
                                            else
                                            {
                                                arr.SetValue(null, i);
                                            }
                                        }
                                    }
                                    csField.SetValue(csInstance, arr);
                                }
                            }
                        }
                    }
                }
            }
            return csInstance;
        }

        /// <summary>
        /// Converts a C# instance to a corresponding C instance.
        /// This function recursively converts fields of a C# instance to their
        /// corresponding C compatible struct instance and assigns them to the
        /// provided C instance.
        /// It handles primitive types, structs, pointers, and arrays.
        /// </summary>
        /// <param name="csInstance">The C# to be converted.</param>
        /// <param name="cInstance">The C-compatible struct instance to which
        /// the converted values will be assigned</param>
        /// <returns>The populated C-compatible struct instance</returns>
        public static object CsToC(object csInstance, object cInstance)
        {
            if (csInstance == null)
                return null;
            foreach (
                var csField in csInstance
                    .GetType()
                    .GetFields(BindingFlags.Public | BindingFlags.Instance)
            )
            {
                var csFieldName = csField.Name;
                var cFieldName = csFieldName;
                var cField = cInstance.GetType().GetField(cFieldName);
                if (csField.GetValue(csInstance) == null)
                    continue;
                if (!IsNullableRefType(csField))
                {
                    if (IsGoPrimitiveType(csField.FieldType))
                    {
                        if (csField.FieldType == typeof(string))
                        {
                            IntPtr ptr = Marshal.StringToHGlobalAnsi(
                                csField.GetValue(csInstance).ToString()
                            );
                            cField.SetValueDirect(__makeref(cInstance), ptr);
                        }
                        else
                        {
                            cField.SetValue(cInstance, csField.GetValue(csInstance));
                        }
                        continue;
                    }
                    else
                    {
                        // The Go struct, for example: excelize.Options, convert sub fields recursively
                        cField.SetValue(
                            cInstance,
                            CsToC(
                                csField.GetValue(csInstance),
                                Activator.CreateInstance(cField.FieldType)
                            )
                        );
                    }
                }
                else
                {
                    if (!csField.FieldType.IsArray)
                    {
                        // Pointer of the Go data type, for example: *excelize.Options or *string
                        if (
                            csField.FieldType == typeof(string)
                            || IsGoPrimitiveType(Nullable.GetUnderlyingType(csField.FieldType))
                        )
                        {
                            // Pointer of the Go basic data type, for example: *string
                            if (csField.FieldType == typeof(string))
                            {
                                IntPtr ptr = Marshal.StringToHGlobalAnsi(
                                    csField.GetValue(csInstance).ToString()
                                );
                                IntPtr ptrPtr = Marshal.AllocHGlobal(IntPtr.Size);
                                Marshal.WriteIntPtr(ptrPtr, ptr);
                                cField.SetValueDirect(__makeref(cInstance), ptrPtr);
                            }
                            else
                            {
                                cField.SetValue(
                                    cInstance,
                                    MarshalPrimitiveValue(csField.GetValue(csInstance))
                                );
                            }
                        }
                        else
                        {
                            // Pointer of the Go struct, for example: *excelize.Options
                            var cType = cField.FieldType.GetElementType();
                            IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(cType));
                            Marshal.StructureToPtr(
                                CsToC(
                                    csField.GetValue(csInstance),
                                    Activator.CreateInstance(cType)
                                ),
                                ptr,
                                false
                            );
                            cField.SetValue(cInstance, ptr);
                        }
                    }
                    else
                    {
                        // The Go data type array, for example:
                        // []*excelize.Options, []excelize.Options, []string, []*string
                        var n = new NullabilityInfoContext().Create(csField);
                        if (n.ElementType.ReadState == NullabilityState.NotNull)
                        {
                            // The Go data type array, for example: []excelize.Options or []string
                            Array list = (Array)csField.GetValue(csInstance);
                            int l = 0;
                            if (list != null)
                                l = list.Length;
                            var csEleType = csField.FieldType.GetElementType();
                            var cEleType = cField.FieldType.GetElementType();
                            Array arr = Array.CreateInstance(csEleType, l);
                            if (l > 0)
                            {
                                IntPtr arrPtr = IntPtr.Zero;
                                if (IsGoPrimitiveType(csEleType))
                                {
                                    // The Go basic data type array, for example: []string
                                    if (csEleType == typeof(string))
                                    {
                                        arrPtr = Marshal.AllocHGlobal(IntPtr.Size * l);
                                        for (int i = 0; i < l; i++)
                                        {
                                            var str = string.Empty;
                                            var val = list.GetValue(i);
                                            if (val != null)
                                                str = val.ToString();
                                            Marshal.WriteIntPtr(
                                                arrPtr,
                                                i * IntPtr.Size,
                                                Marshal.StringToHGlobalAnsi(str)
                                            );
                                        }
                                    }
                                    else
                                    {
                                        int size = Marshal.SizeOf(cEleType);
                                        arrPtr = Marshal.AllocHGlobal(size * l);
                                        for (int i = 0; i < l; i++)
                                        {
                                            Marshal.StructureToPtr(
                                                list.GetValue(i),
                                                arrPtr + (i * size),
                                                false
                                            );
                                        }
                                    }
                                }
                                else
                                {
                                    // The Go struct array, for example: []excelize.Options
                                    if (cEleType != null)
                                    {
                                        int size = Marshal.SizeOf(cEleType);
                                        arrPtr = Marshal.AllocHGlobal(size * l);
                                        for (int i = 0; i < l; i++)
                                        {
                                            var ele = list.GetValue(i);
                                            if (ele != null)
                                            {
                                                object cEle = Activator.CreateInstance(cEleType);
                                                object cVal = CsToC(ele, cEle);
                                                IntPtr elePtr = IntPtr.Add(arrPtr, i * size);
                                                Marshal.StructureToPtr(cVal, elePtr, false);
                                            }
                                        }
                                    }
                                }
                                cField.SetValue(cInstance, arrPtr);
                                var lenField = cInstance
                                    .GetType()
                                    .GetField(
                                        cFieldName + "Len",
                                        BindingFlags.Public | BindingFlags.Instance
                                    );
                                lenField.SetValue(cInstance, l);
                            }
                        }
                        else
                        {
                            // Pointer array of the Go data type, for example:
                            // []*excelize.Options or []*string
                            Array list = (Array)csField.GetValue(csInstance);
                            int l = 0;
                            if (list != null)
                                l = list.Length;
                            Type underlyingType =
                                Nullable.GetUnderlyingType(csField.FieldType.GetElementType())
                                ?? csField.FieldType.GetElementType();
                            if (l > 0)
                            {
                                IntPtr arrPtr = Marshal.AllocHGlobal(IntPtr.Size * l);
                                if (IsGoPrimitiveType(underlyingType))
                                {
                                    // Pointer array of the Go basic data type, for example: []*string
                                    for (int i = 0; i < l; i++)
                                    {
                                        IntPtr elePtr = IntPtr.Zero;
                                        var ele = list.GetValue(i);
                                        if (ele != null)
                                        {
                                            if (underlyingType == typeof(string))
                                            {
                                                elePtr = Marshal.StringToHGlobalAnsi(
                                                    ele.ToString()
                                                );
                                            }
                                            else
                                            {
                                                elePtr = MarshalPrimitiveValue(ele);
                                            }
                                        }
                                        Marshal.WriteIntPtr(arrPtr, i * IntPtr.Size, elePtr);
                                    }
                                }
                                else
                                {
                                    // Pointer array of the Go struct, for example: []*excelize.Options
                                    var cEleType = cField.FieldType.GetElementType();
                                    Type cEleUnderlyingType =
                                        Nullable.GetUnderlyingType(cEleType) ?? cEleType;
                                    if (cEleType != null)
                                    {
                                        for (int i = 0; i < l; i++)
                                        {
                                            var structPtr = IntPtr.Zero;
                                            var ele = list.GetValue(i);
                                            if (ele != null)
                                            {
                                                object cEle = Activator.CreateInstance(cEleType);
                                                object cVal = CsToC(ele, cEle);
                                                structPtr = Marshal.AllocHGlobal(
                                                    Marshal.SizeOf(cEleType)
                                                );
                                                Marshal.StructureToPtr(cVal, structPtr, false);
                                                Marshal.WriteIntPtr(
                                                    arrPtr,
                                                    i * IntPtr.Size,
                                                    structPtr
                                                );
                                            }
                                            Marshal.WriteIntPtr(arrPtr, i * IntPtr.Size, structPtr);
                                        }
                                    }
                                }
                                cField.SetValue(cInstance, arrPtr);
                                var lenField = cInstance
                                    .GetType()
                                    .GetField(
                                        cFieldName + "Len",
                                        BindingFlags.Public | BindingFlags.Instance
                                    );
                                lenField.SetValue(cInstance, l);
                            }
                        }
                    }
                }
            }
            return cInstance;
        }
    }

    public static class Excelize
    {
        /// <summary>
        /// Converts alphanumeric cell name to [X, Y] coordinates or returns an
        /// error.
        /// </summary>
        /// <param name="cell">The cell reference</param>
        /// <returns>Return a tuple containing the column number, row number if
        /// no error occurred</returns>
        /// <exception cref="RuntimeError">Raise a RuntimeError with the message
        /// if an error occurred</exception>
        public static unsafe (int, int) CellNameToCoordinates(string cell)
        {
            TypesC.CellNameToCoordinatesResult res = Lib.CellNameToCoordinates(cell);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return (res.col, res.row);
        }

        /// <summary>
        /// Convert Excel sheet column name (case-insensitive) to int. The
        /// function returns an error if column name incorrect.
        /// </summary>
        /// <param name="name">The column name</param>
        /// <returns>The column number as a integer</returns>
        /// <exception cref="RuntimeError">Raise a RuntimeError with the message
        /// if an error occurred</exception>
        public static unsafe int ColumnNameToNumber(string name)
        {
            TypesC.IntErrorResult res = Lib.ColumnNameToNumber(name);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return res.val;
        }

        /// <summary>
        /// Convert the integer to Excel sheet column title.
        /// </summary>
        /// <param name="num">The column number</param>
        /// <returns>The column name as a string</returns>
        /// <exception cref="RuntimeError">Raise a RuntimeError with the message
        /// if an error occurred</exception>
        public static unsafe string ColumnNumberToName(int num)
        {
            TypesC.StringErrorResult res = Lib.ColumnNumberToName(num);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new(res.val);
        }

        /// <summary>
        /// Converts [X, Y] coordinates to alpha-numeric cell name or returns
        /// an error.
        /// </summary>
        /// <param name="col">The column number</param>
        /// <param name="row">The row number</param>
        /// <param name="abs">Optional boolean indicating whether to use
        /// absolute references. If provided and True, the cell name will use
        /// absolute references (e.g., $A$1)</param>
        /// <returns>Return the cell name as a string if no error occurred,
        /// otherwise raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public static unsafe string CoordinatesToCellName(int col, int row, bool? abs = false)
        {
            TypesC.StringErrorResult res = Lib.CoordinatesToCellName(col, row, abs ?? false);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new(res.val);
        }

        /// <summary>
        /// Create new file by default template.
        /// </summary>
        /// <returns>A populated spreadsheet file struct</returns>
        public static File NewFile()
        {
            return new File { FileIdx = Lib.NewFile() };
        }

        /// <summary>
        /// This function take the name of a spreadsheet file and returns a
        /// populated spreadsheet file struct for it.
        /// </summary>
        /// <param name="filename">The path to the Excel file to open</param>
        /// <param name="options">Optional parameters for opening file</param>
        /// <returns>Return a File object if if no error occurred, otherwise
        /// raise a RuntimeError with the message</returns>
        public static unsafe File OpenFile(string filename, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            var res = Lib.OpenFile(filename, ref opts);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new File { FileIdx = res.val };
        }

        /// <summary>
        /// Read data stream from bytes and return a populated spreadsheet file.
        /// </summary>
        /// <param name="buffer">The contents buffer of the file</param>
        /// <param name="options">Optional parameters for opening file</param>
        /// <returns>Return a File object if if no error occurred</returns>
        /// <exception cref="RuntimeError">Raise a RuntimeError with the message
        /// if an error occurred</exception>
        public static unsafe File OpenReader(byte[] buffer, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            var res = Lib.OpenReader(buffer, buffer.Length, ref opts);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new File { FileIdx = res.val };
        }
    }

    /// <summary>
    /// File is a representation of an workbook.
    /// </summary>
    public class File
    {
        public long FileIdx { get; set; }

        public File() { }

        public File(long fileIdx)
            : this()
        {
            FileIdx = fileIdx;
        }

        /// <summary>
        /// Add chart in a sheet by given chart format set (such as offset,
        /// scale, aspect ratio setting and print settings) and properties set.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="chart">Chart options</param>
        /// <param name="combo">Optional parameters for combo chart</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddChart(string sheet, string cell, Chart chart, params Chart[] combo)
        {
            var l = 1;
            if (combo != null && combo.Length > 0)
            {
                l += combo.Length;
            }
            var arr = new TypesC.Chart[l];
            arr[0] = (TypesC.Chart)Lib.CsToC(chart, new TypesC.Chart());
            if (combo != null && combo.Length > 0)
            {
                for (int i = 0; i < combo.Length; i++)
                {
                    arr[i + 1] = (TypesC.Chart)Lib.CsToC(combo[i], new TypesC.Chart());
                }
            }
            var err = Marshal.PtrToStringAnsi(Lib.AddChart(FileIdx, sheet, cell, arr, arr.Length));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Create a chartsheet by given chart format set (such as offset,
        /// scale, aspect ratio setting and print settings) and properties set.
        /// In Excel a chartsheet is a worksheet that only contains a chart.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="chart">Chart options</param>
        /// <param name="combo">Optional parameters for combo chart</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddChartSheet(string sheet, Chart chart, params Chart[] combo)
        {
            var l = 1;
            if (combo != null && combo.Length > 0)
            {
                l += combo.Length;
            }
            var arr = new TypesC.Chart[l];
            arr[0] = (TypesC.Chart)Lib.CsToC(chart, new TypesC.Chart());
            if (combo != null && combo.Length > 0)
            {
                for (int i = 0; i < combo.Length; i++)
                {
                    arr[i + 1] = (TypesC.Chart)Lib.CsToC(combo[i], new TypesC.Chart());
                }
            }
            var err = Marshal.PtrToStringAnsi(Lib.AddChartSheet(FileIdx, sheet, arr, arr.Length));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Add comments in a sheet by giving the worksheet name, cell
        /// reference, and format set (such as author and text). Note that the
        /// maximum author name length is 255 and the max text length is 32512.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">The comment options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public unsafe void AddComment(string sheet, Comment? options = null)
        {
            if (options == null)
                return;
            var opts = (TypesC.Comment)Lib.CsToC(options, new TypesC.Comment());
            var err = Marshal.PtrToStringAnsi(Lib.AddComment(FileIdx, sheet, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Add picture in a sheet by given picture format set (such as offset,
        /// scale, aspect ratio setting and print settings) and file path.
        /// Supported image types: GIF, JPEG, JPG, PNG, TIF and TIFF. Note that
        /// this function only supports adding pictures placed over the cells
        /// currently, and doesn't support adding pictures placed in cells or
        /// creating the Kingsoft WPS Office embedded image cells.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="name">The image file path</param>
        /// <param name="options">The image options</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        /// <example>
        /// For example:
        /// <code>
        /// using ExcelizeCs;
        /// class Program
        /// {
        ///     static void Main()
        ///     {
        ///         ExcelizeCs.File? f;
        ///         try
        ///         {
        ///             f = Excelize.OpenFile("Book1.xlsx");
        ///         }
        ///         catch (RuntimeError err)
        ///         {
        ///             Console.WriteLine(err.Message);
        ///             return;
        ///         }
        ///         try
        ///         {
        ///             // Insert a picture.
        ///             f.AddPicture("Sheet1", "A1", "image.png", null);
        ///             // Insert a picture to worksheet with scaling.
        ///             f.AddPicture(
        ///                 "Sheet1",
        ///                 "A1",
        ///                 "image.jpg",
        ///                 new GraphicOptions
        ///                 {
        ///                     ScaleX = 0.1,
        ///                     ScaleY = 0.1,
        ///                 }
        ///             );
        ///             // Insert a picture offset in the cell with printing support.
        ///             f.AddPicture(
        ///                 "Sheet1",
        ///                 "A1",
        ///                 "image.jpg",
        ///                 new GraphicOptions
        ///                 {
        ///                     PrintObject = true,
        ///                     LockAspectRatio = false,
        ///                     OffsetX = 15,
        ///                     OffsetY = 10,
        ///                     Locked = false,
        ///                 }
        ///             );
        ///             // Save the spreadsheet with the origin path.
        ///             f.Save();
        ///         }
        ///         catch (RuntimeError err)
        ///         {
        ///             Console.WriteLine(err.Message);
        ///         }
        ///         finally
        ///         {
        ///             // Close the spreadsheet.
        ///             var err = f.Close();
        ///             if (!string.IsNullOrEmpty(err))
        ///                 Console.WriteLine(err);
        ///         }
        ///     }
        /// }
        /// </code>
        /// </example>
        public void AddPicture(string sheet, string cell, string name, GraphicOptions? options)
        {
            var opts = (TypesC.GraphicOptions)
                Lib.CsToC(options ?? new GraphicOptions(), new TypesC.GraphicOptions());
            var err = Marshal.PtrToStringAnsi(Lib.AddPicture(FileIdx, sheet, cell, name, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Add vbaProject.bin file which contains functions and/or macros. The
        /// file extension should be XLSM or XLTM.
        /// </summary>
        /// <param name="buffer">The contents buffer of the file</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void AddVBAProject(byte[] buffer)
        {
            var err = Marshal.PtrToStringAnsi(Lib.AddVBAProject(FileIdx, buffer, buffer.Length));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Closes and cleanup the open temporary file for the spreadsheet.
        /// </summary>
        /// <returns>Returns an error message if the operation fails, otherwise
        /// returns an empty string.</returns>
        public string Close()
        {
            return Marshal.PtrToStringAnsi(Lib.Close(FileIdx));
        }

        /// <summary>
        /// Get formatted value from cell by given worksheet name and cell
        /// reference in spreadsheet. The return value is converted to the
        /// 'string' data type. If the cell format can be applied to the value
        /// of a cell, the applied value will be returned, otherwise the
        /// original value will be returned. All cells' values will be the same
        /// in a merged range.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="options">Optional parameters for get cell value</param>
        /// <returns>Return the cell value if no error occurred, otherwise raise
        /// a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError"></exception>
        public unsafe string GetCellValue(string sheet, string cell, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            TypesC.StringErrorResult res = Lib.GetCellValue(FileIdx, sheet, cell, ref opts);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return new(res.val);
        }

        /// <summary>
        /// Return all the rows in a sheet by given worksheet name, returned as
        /// a two-dimensional array, where the value of the cell is converted to
        /// the string type. If the cell format can be applied to the value of
        /// the cell, the applied value will be used, otherwise the original
        /// value will be used. This function fetched the rows with value or
        /// formula cells, the continually blank cells in the tail of each row
        /// will be skipped, so the length of each row may be inconsistent.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="options">Optional parameters for get rows</param>
        /// <returns>Return all the rows in a sheet by given worksheet name,
        /// returned as a two-dimensional array if no error occurred, otherwise
        /// raise a RuntimeError with the message.</returns>
        /// <example>
        /// For example, get and traverse the value of all cells by rows on a
        /// worksheet named 'Sheet1':
        /// <code>
        /// var rows = f.GetRows("Sheet1");
        /// foreach (var row in rows)
        /// {
        ///     foreach (var cell in row)
        ///     {
        ///         Console.Write($"{cell}\t");
        ///     }
        ///     Console.WriteLine();
        /// }
        /// </code>
        /// </example>
        public unsafe List<List<string>> GetRows(string sheet, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            TypesC.GetRowsResult res = Lib.GetRows(FileIdx, sheet, ref opts);
            var rows = new List<List<string>>();
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            var result = (GetRowsResult)Lib.CToCs(res, new GetRowsResult());
            foreach (var r in result.Row)
            {
                var row = new List<string>();
                if (r.Cell != null)
                {
                    foreach (var c in r.Cell)
                    {
                        row.Add(c);
                    }
                }
                rows.Add(row);
            }
            return rows;
        }

        /// <summary>
        /// Get style definition by given style ID.
        /// </summary>
        /// <param name="styleId">The style ID</param>
        /// <returns>Return the style definition if no error occurred, otherwise
        /// raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError"></exception>
        public unsafe Style GetStyle(long styleId)
        {
            TypesC.GetStyleResult res = Lib.GetStyle(FileIdx, styleId);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            var style = (Style)Lib.CToCs(res.style, new Style());
            return style;
        }

        /// <summary>
        /// Create a new sheet by given a worksheet name and returns the index
        /// of the sheets in the workbook after it appended. Note that when
        // creating a new workbook, the default worksheet named `Sheet1` will be
        // created.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <returns>Return the index of the sheets in the workbook if no error
        /// occurred, otherwise raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError"></exception>
        public unsafe int NewSheet(string sheet)
        {
            var res = Lib.NewSheet(FileIdx, sheet);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return res.val;
        }

        /// <summary>
        /// Create the style for cells by a given style options, and returns
        /// style index. The same style index can not be used across different
        /// workbook. Note that the 'font.color' field uses an RGB color
        /// represented in 'RRGGBB' hexadecimal notation.
        /// </summary>
        /// <param name="style">The style options</param>
        /// <returns>Return the style index if no error occurred, otherwise
        /// raise a RuntimeError with the message.</returns>
        /// <exception cref="RuntimeError"></exception>
        public unsafe int NewStyle(Style style)
        {
            var options = (TypesC.Style)Lib.CsToC(style, new TypesC.Style());
            var res = Lib.NewStyle(FileIdx, ref options);
            string err = new(res.err);
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
            return res.val;
        }

        /// <summary>
        /// Override the spreadsheet with origin path.
        /// </summary>
        /// <param name="options">Optional parameters for saving the file</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void Save(Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            var err = Marshal.PtrToStringAnsi(Lib.Save(FileIdx, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Create or update to a spreadsheet at the provided path.
        /// </summary>
        /// <param name="filename">The name of the file to save</param>
        /// <param name="options">Optional parameters for saving the file</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SaveAs(string filename, Options? options = null)
        {
            var opts = (TypesC.Options)Lib.CsToC(options ?? new Options(), new TypesC.Options());
            var err = Marshal.PtrToStringAnsi(Lib.SaveAs(FileIdx, filename, ref opts));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>Set the default active sheet of the workbook by a given
        /// index.
        /// </summary>
        /// <remarks>Note that the active index is different from the ID
        /// returned by function `GetSheetMap`. It should be greater than or
        /// equal to 0 and less than the total worksheet numbers.</remarks>
        /// <param name="index">The index of the worksheet to be set as active.
        /// </param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetActiveSheet(int index)
        {
            var err = Marshal.PtrToStringAnsi(Lib.SetActiveSheet(FileIdx, index));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set int type value of a cell by given worksheet name, cell reference
        /// and cell value.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="value">The cell value</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCellInt(string sheet, string cell, long value)
        {
            var err = Marshal.PtrToStringAnsi(Lib.SetCellInt(FileIdx, sheet, cell, value));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set int type value of a cell by given worksheet name, cell reference
        /// and cell value.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="topLeftCell">The cell reference</param>
        /// <param name="bottomRightCell">The cell value</param>
        /// <param name="styleID">The cell value</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCellStyle(
            string sheet,
            string topLeftCell,
            string bottomRightCell,
            long styleID
        )
        {
            var err = Marshal.PtrToStringAnsi(
                Lib.SetCellStyle(FileIdx, sheet, topLeftCell, bottomRightCell, styleID)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Set value of a cell by given worksheet name, cell reference and cell
        /// value.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="value">The cell value</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetCellValue(string sheet, string cell, object value)
        {
            var val = (TypesC.Interface)Lib.CsValToCInterface(value);
            var err = Marshal.PtrToStringAnsi(Lib.SetCellValue(FileIdx, sheet, cell, ref val));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Writes cells to row by given worksheet name, starting cell reference
        /// and cell values list.
        /// </summary>
        /// <param name="sheet">The worksheet name</param>
        /// <param name="cell">The cell reference</param>
        /// <param name="values">The cell values</param>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void SetSheetRow(string sheet, string cell, List<object> values)
        {
            if (values == null || values.Count == 0)
                return;
            var arr = new TypesC.Interface[values.Count];
            for (int i = 0; i < values.Count; i++)
            {
                arr[i] = (TypesC.Interface)Lib.CsValToCInterface(values[i]);
            }
            var err = Marshal.PtrToStringAnsi(
                Lib.SetSheetRow(FileIdx, sheet, cell, arr, values.Count)
            );
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }

        /// <summary>
        /// Fix linked values within a spreadsheet are not updating in Office
        /// Excel application. This function will be remove value tag when met a
        /// cell have a linked value.
        /// </summary>
        /// <remarks>After opening generated workbook, Excel will update the
        /// linked value and generate a new value and will prompt to save the
        /// file or not.</remarks>
        /// <exception cref="RuntimeError">Return None if no error occurred,
        /// otherwise raise a RuntimeError with the message.</exception>
        public void UpdateLinkedValue()
        {
            var err = Marshal.PtrToStringAnsi(Lib.UpdateLinkedValue(FileIdx));
            if (!string.IsNullOrEmpty(err))
                throw new RuntimeError(err);
        }
    }

    /// <summary>
    /// RuntimeError is raised when an error occurs during the execution of a
    /// function in the Excelize library.
    /// </summary>
    /// <remarks>The RuntimeError class extends the built-in Exception class
    /// and provides a way to represent errors specific to the Excelize
    /// library.</remarks>
    public class RuntimeError : Exception
    {
        /// <summary>
        /// Initializes a new instance of the RuntimeError class.
        /// </summary>
        /// <param name="message">The error message.</param>
        public RuntimeError(string message)
            : base(message) { }
    }
}
